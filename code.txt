Directory Structure:
-------------------
/ 
├── .husky/
│   ├── _/
│   │   ├── .gitignore
│   │   ├── applypatch-msg
│   │   ├── commit-msg
│   │   ├── h
│   │   ├── husky.sh
│   │   ├── post-applypatch
│   │   ├── post-checkout
│   │   ├── post-commit
│   │   ├── post-merge
│   │   ├── post-rewrite
│   │   ├── pre-applypatch
│   │   ├── pre-auto-gc
│   │   ├── pre-commit
│   │   ├── pre-merge-commit
│   │   ├── pre-push
│   │   ├── pre-rebase
│   │   └── prepare-commit-msg
│   └── pre-commit
├── .vscode/
│   └── launch.json
├── src/
│   ├── common/
│   │   ├── constants/
│   │   │   └── constants.ts
│   │   ├── jwt/
│   │   │   └── jwt.ts
│   │   ├── mail-sender/
│   │   │   └── mail-sender.ts
│   │   ├── multer/
│   │   │   ├── delete-file-from-disk.ts
│   │   │   ├── multer.ts
│   │   │   ├── save-file-to-disk.ts
│   │   │   └── update-file-to-disk.ts
│   │   ├── repository/
│   │   │   └── repository.ts
│   │   ├── swagger/
│   │   │   ├── swagger-document-generator.ts
│   │   │   ├── swagger-response-builder.ts
│   │   │   ├── swagger-response.ts
│   │   │   └── swagger.router.ts
│   │   └── winston/
│   │       └── winston.ts
│   ├── config/
│   │   ├── mongodb/
│   │   │   └── mongodb.ts
│   │   ├── redis/
│   │   │   └── redis.ts
│   │   └── env.ts
│   ├── entities/
│   │   ├── auth/
│   │   │   ├── auth.controller.ts
│   │   │   ├── auth.dto.ts
│   │   │   ├── auth.route.ts
│   │   │   └── auth.services.ts
│   │   ├── files/
│   │   │   ├── files.controller.ts
│   │   │   ├── files.dto.ts
│   │   │   ├── files.repository.ts
│   │   │   ├── files.route.ts
│   │   │   └── files.service.ts
│   │   ├── health/
│   │   │   ├── health.controller.ts
│   │   │   ├── health.helper.ts
│   │   │   └── health.route.ts
│   │   └── users/
│   │       ├── users.controller.ts
│   │       ├── users.dto.ts
│   │       ├── users.route.ts
│   │       └── users.service.ts
│   ├── middlewares/
│   │   ├── auth-middleware.ts
│   │   ├── cors.ts
│   │   ├── error-middleware.ts
│   │   ├── index.ts
│   │   └── zod-validation.ts
│   ├── models/
│   │   └── error-logs.ts
│   ├── routes/
│   │   └── routes.ts
│   ├── schemas/
│   │   ├── find-by-query.ts
│   │   ├── import-file.ts
│   │   └── query-examples.txt
│   ├── template/
│   │   ├── create-template.ts
│   │   └── forgot-password.hbs
│   ├── types/
│   │   ├── pagination.ts
│   │   └── request.ts
│   ├── utils/
│   │   ├── create-response.ts
│   │   ├── csv-to-json.ts
│   │   ├── mongodb-apply-filter.ts
│   │   └── utils.ts
│   ├── .DS_Store
│   ├── app.ts
│   └── server.ts
├── tests/
│   └── auth.validation.test.ts
├── uploads/
│   ├── file-1732863659479-858448142.png
│   ├── file-1732864787666-267731371.png
│   └── file-1733207824665-322188582.png
├── .DS_Store
├── .env
├── .env.example
├── .gitignore
├── .prettierignore
├── .prettierrc
├── code-structure.txt
├── eslint.config.mjs
├── jest.config.ts
├── nodemon.json
├── package.json
├── README.md
└── tsconfig.json

File Contents:
--------------
File: ./nodemon.json
--------------------------------------------------
Content of ./nodemon.json:
{
  "watch": ["src"],
  "ignore": [".git", "node_modules", "build"],
  "ext": "ts",
  "exec": "ts-node -r tsconfig-paths/register src/server.ts"
}


File: ./.DS_Store
--------------------------------------------------
Error reading file: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte. Content skipped.


File: ./.prettierignore
--------------------------------------------------
Content of ./.prettierignore:
# Ignore artifacts:
node_modules
build
coverage
dist

File: ./README.md
--------------------------------------------------
Content of ./README.md:
# epressjs-nest-structure

File: ./.gitignore
--------------------------------------------------
Content of ./.gitignore:
# Node modules
node_modules/

# Build output
dist/
build/

# TypeScript files
*.tsbuildinfo

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE and editor folders
.vscode/
.idea/
*.swp
*.swo
*.sublime-project
*.sublime-workspace

# Temporary files
.DS_Store
Thumbs.db
*.tmp
*.temp

# OS generated files
ehthumbs.db
Icon?
Desktop.ini

# Coverage directory used by tools like istanbul
coverage/

# Jest test results
jest/

uploads/

File: ./package.json
--------------------------------------------------
Content of ./package.json:
{
  "name": "epressjs-nest-structure",
  "version": "2.0.0",
  "description": "",
  "main": "build/src/server.js",
  "scripts": {
    "clean": "rimraf build/",
    "build": "npm run clean && tsc && tsc-alias",
    "start": "npm run build && node --optimize_for_size build/src/server.js",
    "dev": "nodemon -exec --config nodemon.json 'ts-node' src/server.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "prettier": "prettier --write src/**",
    "prettier:check": "prettier --check src/**",
    "prepare": "husky"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/TKAkhter/epressjs-nest-structure"
  },
  "bugs": {
    "url": "https://github.com/TKAkhter/epressjs-nest-structure/issues"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ]
  },
  "homepage": "https://github.com/TKAkhter/epressjs-nest-structure#readme",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@asteasolutions/zod-to-openapi": "^7.2.0",
    "@typescript-eslint/eslint-plugin": "^8.15.0",
    "@typescript-eslint/parser": "^8.15.0",
    "@zodyac/zod-mongoose": "^3.0.0",
    "axios": "^1.7.7",
    "bcrypt": "^5.1.1",
    "colors": "^1.4.0",
    "compression": "^1.7.5",
    "connect-timeout": "^1.9.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "csv-parser": "^3.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-rate-limit": "^7.4.1",
    "express-slow-down": "^2.0.3",
    "form-data": "^4.0.1",
    "handlebars": "^4.7.8",
    "helmet": "^8.0.0",
    "hpp": "^0.2.3",
    "http-errors": "^2.0.0",
    "http-status-codes": "^2.3.0",
    "ioredis": "^5.4.1",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.2",
    "juice": "^11.0.0",
    "lodash": "^4.17.21",
    "mailgun.js": "^11.1.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "nocache": "^4.0.0",
    "nodemon": "^3.1.7",
    "redis": "^4.7.0",
    "reflect-metadata": "^0.2.2",
    "response-time": "^2.3.3",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^11.0.3",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^5.0.0",
    "winston-mongodb": "^6.0.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@eslint/js": "^9.15.0",
    "@types/bcrypt": "^5.0.2",
    "@types/compression": "^1.7.5",
    "@types/connect-timeout": "^0.0.39",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/hpp": "^0.2.6",
    "@types/jest": "^29.5.14",
    "@types/json2csv": "^5.0.7",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/lodash": "^4.17.14",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.12",
    "@types/node": "^22.9.0",
    "@types/response-time": "^2.3.8",
    "@types/supertest": "^6.0.2",
    "@types/swagger-ui-express": "^4.1.7",
    "eslint": "^9.15.0",
    "eslint-plugin-import": "^2.31.0",
    "globals": "^15.12.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "lint-staged": "^15.2.10",
    "prettier": "^3.3.3",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "tsc-alias": "^1.8.10",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.14.0"
  }
}

File: ./.prettierrc
--------------------------------------------------
Content of ./.prettierrc:
{
  "bracketSameLine": false,
  "bracketSpacing": true,
  "endOfLine": "lf",
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "trailingComma": "all",
  "useTabs": false,
  "printWidth": 100,
  "arrowParens": "always",
  "embeddedLanguageFormatting": "auto"
}


File: ./tsconfig.json
--------------------------------------------------
Content of ./tsconfig.json:
{
  "compilerOptions": {
    "incremental": true,
    "target": "es2019",
    "module": "commonjs",
    "declaration": true,
    "sourceMap": true,
    "removeComments": true,
    "outDir": "./build",
    "skipLibCheck": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictBindCallApply": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": "./",
    "resolveJsonModule": true,
    "paths": {
      "@/*": ["./src/*"]
    },
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "tsc-alias": {
    "verbose": false,
    "resolveFullPaths": true
  },
  "include": ["src", "src/types", "./node_modules/@types", "@types/jest", "tests"],
  "exclude": ["node_modules", "build"]
}


File: ./.env.example
--------------------------------------------------
Content of ./.env.example:
NODE_ENV=NODE_ENV
BASE_URL=BASE_URL
BASE_URL_HTTPS=BASE_URL_HTTPS
PORT=PORT
SERVER_TIMEOUT=SERVER_TIMEOUT
LOG_FILE_DURATION=LOG_FILE_DURATION
ALLOW_ORIGIN=ALLOW_ORIGIN

## -- Redis --
REDIS_URL=REDIS_URL

# MongoDB
MONGODB_URI=MONGODB_URI

## -- Basic Auth secrets --
JWT_SECRET=JWT_SECRET
JWT_SECRET_EXPIRATION=JWT_SECRET_EXPIRATION
HASH=HASH

ENABLE_WINSTON=ENABLE_WINSTON


File: ./eslint.config.mjs
--------------------------------------------------
Content of ./eslint.config.mjs:
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import importPlugin from "eslint-plugin-import";


export default [{ files: ["**/*.{js,mjs,cjs,ts}"] },
{ languageOptions: { globals: globals.browser } },
pluginJs.configs.recommended,
...tseslint.configs.recommended,
{
  plugins: {
    importPlugin
  },
  "rules": {
    "accessor-pairs": ["error"],
    // "array-bracket-newline": ["error"],
    "array-bracket-spacing": ["error"],
    "array-callback-return": ["error"],
    // "array-element-newline": ["error"],
    // "arrow-body-style": ["error"],
    "arrow-parens": ["error"],
    "arrow-spacing": ["error"],
    "block-scoped-var": ["error"],
    "block-spacing": ["error"],
    // "brace-style": ["error"],
    "camelcase": ["error"],
    "capitalized-comments": ["error"],
    // "class-methods-use-this": "off",
    "comma-dangle": ["error"],
    "comma-spacing": ["error"],
    // "comma-style": ["error"],
    "computed-property-spacing": ["error"],
    "consistent-this": ["error"],
    "constructor-super": ["error"],
    "curly": ["error"],
    "default-case": ["error"],
    "default-case-last": ["error"],
    "default-param-last": ["error"],
    "dot-location": ["error"],
    "dot-notation": ["error"],
    "eol-last": ["error"],
    "eqeqeq": ["error"],
    "for-direction": ["error"],
    "func-call-spacing": ["error"],
    "func-name-matching": ["error"],
    "func-names": ["error"],
    // "function-call-argument-newline": ["error"],
    // "function-paren-newline": ["error"],
    "generator-star-spacing": ["error"],
    "getter-return": ["error"],
    "global-require": ["error"],
    "grouped-accessor-pairs": ["error"],
    "guard-for-in": ["error"],
    "handle-callback-err": ["error"],
    "id-blacklist": ["error"],
    "id-denylist": ["error"],
    "id-match": ["error"],
    // "implicit-arrow-linebreak": ["error"],
    "indent": ["error"],
    // "indent-legacy": ["error"],
    // "init-declarations": ["error"],
    "jsx-quotes": ["error"],
    "key-spacing": ["error"],
    "keyword-spacing": ["error"],
    // "linebreak-style": ["error"],
    // "lines-around-comment": ["error"],
    // "lines-around-directive": ["error"],
    "lines-between-class-members": "off",
    "logical-assignment-operators": ["error"],
    "max-classes-per-file": ["error"],
    "max-depth": ["error"],
    // "max-lines": ["error"],
    "max-nested-callbacks": ["error"],
    "max-statements-per-line": ["error"],
    // "multiline-comment-style": ["error"],
    "multiline-ternary": ["error"],
    "new-parens": ["error"],
    // "newline-after-var": ["error"],
    // "newline-before-return": ["error"],
    // "newline-per-chained-call": ["error"],
    "no-alert": ["error"],
    "no-array-constructor": ["error"],
    "no-async-promise-executor": ["error"],
    "no-await-in-loop": ["error"],
    "no-bitwise": ["error"],
    "no-buffer-constructor": ["error"],
    "no-caller": ["error"],
    "no-case-declarations": ["error"],
    "no-catch-shadow": ["error"],
    "no-class-assign": ["error"],
    "no-compare-neg-zero": ["error"],
    "no-cond-assign": ["error"],
    "no-confusing-arrow": ["error"],
    "no-const-assign": ["error"],
    "no-constant-binary-expression": ["error"],
    "no-constant-condition": ["error"],
    "no-constructor-return": ["error"],
    "no-continue": ["error"],
    "no-control-regex": ["error"],
    "no-debugger": ["error"],
    "no-delete-var": ["error"],
    "no-div-regex": ["error"],
    "no-dupe-args": ["error"],
    "no-dupe-class-members": ["error"],
    "no-dupe-else-if": ["error"],
    "no-dupe-keys": ["error"],
    "no-duplicate-case": ["error"],
    "no-duplicate-imports": ["error"],
    "no-else-return": ["error"],
    "no-empty": ["error"],
    "no-empty-character-class": ["error"],
    "no-empty-function": ["error"],
    "no-empty-pattern": ["error"],
    "no-empty-static-block": ["error"],
    "no-eq-null": ["error"],
    "no-eval": ["error"],
    "no-ex-assign": ["error"],
    "no-extend-native": ["error"],
    "no-extra-bind": ["error"],
    "no-extra-boolean-cast": ["error"],
    "no-extra-label": ["error"],
    "no-extra-parens": ["error"],
    "no-extra-semi": ["error"],
    "no-fallthrough": ["error"],
    "no-floating-decimal": ["error"],
    "no-func-assign": ["error"],
    "no-global-assign": ["error"],
    "no-implicit-coercion": ["error"],
    "no-implicit-globals": ["error"],
    "no-implied-eval": ["error"],
    "no-import-assign": ["error"],
    "no-inner-declarations": ["error"],
    "no-invalid-regexp": ["error"],
    "no-invalid-this": ["error"],
    "no-irregular-whitespace": ["error"],
    "no-iterator": ["error"],
    "no-label-var": ["error"],
    "no-labels": ["error"],
    "no-lone-blocks": ["error"],
    "no-lonely-if": ["error"],
    "no-loop-func": ["error"],
    "no-loss-of-precision": ["error"],
    "no-misleading-character-class": ["error"],
    "no-mixed-operators": ["error"],
    "no-mixed-requires": ["error"],
    "no-mixed-spaces-and-tabs": ["error"],
    "no-multi-assign": ["error"],
    "no-multi-spaces": ["error"],
    "no-multi-str": ["error"],
    "no-multiple-empty-lines": ["error", { max: 1 }],
    "no-native-reassign": ["error"],
    // "no-negated-condition": ["error"],
    "no-negated-in-lhs": ["error"],
    "no-new": ["error"],
    "no-new-func": ["error"],
    "no-new-native-nonconstructor": ["error"],
    "no-new-object": ["error"],
    "no-new-require": ["error"],
    "no-new-symbol": ["error"],
    "no-new-wrappers": ["error"],
    "no-nonoctal-decimal-escape": ["error"],
    "no-obj-calls": ["error"],
    "no-object-constructor": ["error"],
    "no-octal": ["error"],
    "no-octal-escape": ["error"],
    "no-param-reassign": ["error"],
    "no-path-concat": ["error"],
    "no-plusplus": ["error"],
    "no-process-exit": ["error"],
    "no-promise-executor-return": ["error"],
    "no-proto": ["error"],
    "no-prototype-builtins": ["error"],
    "no-redeclare": ["error"],
    "no-regex-spaces": ["error"],
    "no-restricted-exports": ["error"],
    "no-restricted-globals": ["error"],
    "no-restricted-imports": ["error"],
    "no-restricted-modules": ["error"],
    "no-restricted-properties": ["error"],
    "no-restricted-syntax": ["error"],
    "no-return-assign": ["error"],
    "no-return-await": ["error"],
    "no-script-url": ["error"],
    "no-self-assign": ["error"],
    "no-self-compare": ["error"],
    "no-sequences": ["error"],
    "no-setter-return": ["error"],
    "no-shadow": ["error"],
    "no-shadow-restricted-names": ["error"],
    "no-spaced-func": ["error"],
    "no-sparse-arrays": ["error"],
    "no-sync": "off",
    "no-tabs": ["error"],
    "no-template-curly-in-string": ["error"],
    "no-this-before-super": ["error"],
    "no-throw-literal": ["error"],
    "no-trailing-spaces": ["error"],
    "no-undef-init": ["error"],
    // "no-undefined": ["error"],
    "no-underscore-dangle": ["error"],
    "no-unexpected-multiline": ["error"],
    "no-unmodified-loop-condition": ["error"],
    "no-unneeded-ternary": ["error"],
    "no-unreachable": ["error"],
    "no-unreachable-loop": ["error"],
    "no-unsafe-finally": ["error"],
    "no-unsafe-negation": ["error"],
    "no-unsafe-optional-chaining": ["error"],
    "no-unused-expressions": "off",
    "@typescript-eslint/no-unused-expressions": ["error", { "allowShortCircuit": true }],
    "no-unused-labels": ["error"],
    "no-unused-private-class-members": ["error"],
    "no-use-before-define": ["error"],
    "no-useless-assignment": ["error"],
    "no-useless-backreference": ["error"],
    "no-useless-call": ["error"],
    "no-useless-catch": ["error"],
    "no-useless-computed-key": ["error"],
    "no-useless-concat": ["error"],
    "no-useless-constructor": ["error"],
    "no-useless-escape": ["error"],
    "no-useless-rename": ["error"],
    "no-useless-return": ["error"],
    "no-var": ["error"],
    "no-void": ["error"],
    "no-warning-comments": ["error"],
    "no-whitespace-before-property": ["error"],
    "no-with": ["error"],
    "nonblock-statement-body-position": ["error"],
    // "object-curly-newline": ["error"],
    // "object-curly-spacing": ["error"],
    // "object-property-newline": ["error"],
    "object-shorthand": ["error"],
    "one-var-declaration-per-line": ["error"],
    "operator-assignment": ["error"],
    // "operator-linebreak": ["error"],
    "padded-blocks": "off",
    "padding-line-between-statements": "off",
    "prefer-arrow-callback": ["error"],
    "prefer-const": ["error"],
    "prefer-destructuring": ["error"],
    "prefer-exponentiation-operator": ["error"],
    "prefer-numeric-literals": ["error"],
    "prefer-object-has-own": ["error"],
    "prefer-object-spread": ["error"],
    "prefer-promise-reject-errors": ["error"],
    "prefer-reflect": ["error"],
    "prefer-regex-literals": ["error"],
    "prefer-rest-params": ["error"],
    "prefer-spread": ["error"],
    "prefer-template": ["error"],
    "quote-props": ["error"],
    "quotes": ["error"],
    "radix": ["error"],
    // "require-atomic-updates": "off",
    "require-yield": ["error"],
    "rest-spread-spacing": ["error"],
    "semi": ["error"],
    "semi-spacing": ["error"],
    // "semi-style": ["error"],
    "sort-imports": ["off"],
    // "space-before-blocks": ["error"],
    // "space-before-function-paren": ["error"],
    // "space-in-parens": ["error"],
    // "space-infix-ops": ["error"],
    // "space-unary-ops": ["error"],
    // "spaced-comment": ["error"],
    "strict": ["error"],
    // "switch-colon-spacing": ["error"],
    // "symbol-description": ["error"],
    // "template-curly-spacing": ["error"],
    // "template-tag-spacing": ["error"],
    "unicode-bom": ["error"],
    "use-isnan": ["error"],
    "valid-typeof": ["error"],
    "vars-on-top": ["error"],
    "wrap-iife": ["error"],
    "wrap-regex": ["error"],
    // "yield-star-spacing": ["error"],
    "yoda": ["error"],
  }
}
];

File: ./jest.config.ts
--------------------------------------------------
Content of ./jest.config.ts:
/**
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

import { pathsToModuleNameMapper, JestConfigWithTsJest } from "ts-jest";
import { compilerOptions } from "./tsconfig.json";

/** @type {import('jest').Config} */
const jestConfig: JestConfigWithTsJest = {
  // All imported modules in your tests should be mocked automatically
  // Automock: false,

  // Stop running tests after `n` failures
  // Bail: 0,

  // The directory where Jest should store its cached dependency information
  // CacheDirectory: "/private/var/folders/b9/m478lz_d2632k8g9wfsm5lj00000gn/T/jest_dx",

  // Automatically clear mock calls, instances, contexts and results before every test
  // ClearMocks: false,

  // Indicates whether the coverage information should be collected while executing the test
  // CollectCoverage: false,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // CollectCoverageFrom: undefined,

  // The directory where Jest should output its coverage files
  // CoverageDirectory: undefined,

  // An array of regexp pattern strings used to skip coverage collection
  // CoveragePathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // Indicates which provider should be used to instrument code for coverage
  // CoverageProvider: "babel",

  // A list of reporter names that Jest uses when writing coverage reports
  // CoverageReporters: [
  //   "json",
  //   "text",
  //   "lcov",
  //   "clover"
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // CoverageThreshold: undefined,

  // A path to a custom dependency extractor
  // DependencyExtractor: undefined,

  // Make calling deprecated APIs throw helpful error messages
  // ErrorOnDeprecated: false,

  // The default configuration for fake timers
  // FakeTimers: {
  //   "enableGlobally": false
  // },

  // Force coverage collection from ignored files using an array of glob patterns
  // ForceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // GlobalSetup: undefined,

  // A path to a module which exports an async function that is triggered once after all test suites
  // GlobalTeardown: undefined,

  // A set of global variables that need to be available in all test environments
  // Globals: {},

  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
  // MaxWorkers: "50%",

  // An array of directory names to be searched recursively up from the requiring module's location
  moduleDirectories: ["node_modules", "./src"],

  // An array of file extensions your modules use
  // ModuleFileExtensions: [
  //   "js",
  //   "mjs",
  //   "cjs",
  //   "jsx",
  //   "ts",
  //   "tsx",
  //   "json",
  //   "node"
  // ],

  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
  moduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths, { prefix: "<rootDir>/" }),

  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
  // ModulePathIgnorePatterns: [],

  // Activates notifications for test results
  // Notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // NotifyMode: "failure-change",

  // A preset that is used as a base for Jest's configuration
  preset: "ts-jest",

  // Run tests from one or more projects
  // Projects: undefined,

  // Use this configuration option to add custom reporters to Jest
  // Reporters: undefined,

  // Automatically reset mock state before every test
  // ResetMocks: false,

  // Reset the module registry before running each individual test
  // ResetModules: false,

  // A path to a custom resolver
  // Resolver: undefined,

  // Automatically restore mock state and implementation before every test
  // RestoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // RootDir: undefined,

  // A list of paths to directories that Jest should use to search for files in
  // Roots: [
  //   "<rootDir>"
  // ],

  // Allows you to use a custom runner instead of Jest's default test runner
  // Runner: "jest-runner",

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // SetupFiles: [],

  // A list of paths to modules that run some code to configure or set up the testing framework before each test
  // SetupFilesAfterEnv: [],

  // The number of seconds after which a test is considered as slow and reported as such in the results.
  // SlowTestThreshold: 5,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // SnapshotSerializers: [],

  // The test environment that will be used for testing
  // TestEnvironment: "jest-environment-node",

  // Options that will be passed to the testEnvironment
  // TestEnvironmentOptions: {},

  // Adds a location field to test results
  // TestLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // TestMatch: [
  //   "**/__tests__/**/*.[jt]s?(x)",
  //   "**/?(*.)+(spec|test).[tj]s?(x)"
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // TestPathIgnorePatterns: [
  //   "/node_modules/"
  // ],

  // The regexp pattern or array of patterns that Jest uses to detect test files
  // TestRegex: [],

  // This option allows the use of a custom results processor
  // TestResultsProcessor: undefined,

  // This option allows use of a custom test runner
  // TestRunner: "jest-circus/runner",

  // A map from regular expressions to paths to transformers
  // Transform: undefined,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // TransformIgnorePatterns: [
  //   "/node_modules/",
  //   "\\.pnp\\.[^\\/]+$"
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // UnmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // Verbose: undefined,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // WatchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // Watchman: true,
};

export default jestConfig;


File: .husky/pre-commit
--------------------------------------------------
Content of .husky/pre-commit:
npx lint-staged


File: .husky/_/pre-rebase
--------------------------------------------------
Content of .husky/_/pre-rebase:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-applypatch
--------------------------------------------------
Content of .husky/_/pre-applypatch:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/husky.sh
--------------------------------------------------
Content of .husky/_/husky.sh:
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"

File: .husky/_/pre-auto-gc
--------------------------------------------------
Content of .husky/_/pre-auto-gc:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-merge-commit
--------------------------------------------------
Content of .husky/_/pre-merge-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-commit
--------------------------------------------------
Content of .husky/_/post-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/applypatch-msg
--------------------------------------------------
Content of .husky/_/applypatch-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/prepare-commit-msg
--------------------------------------------------
Content of .husky/_/prepare-commit-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/h
--------------------------------------------------
Content of .husky/_/h:
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c


File: .husky/_/post-checkout
--------------------------------------------------
Content of .husky/_/post-checkout:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-applypatch
--------------------------------------------------
Content of .husky/_/post-applypatch:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/.gitignore
--------------------------------------------------
Content of .husky/_/.gitignore:
*

File: .husky/_/post-rewrite
--------------------------------------------------
Content of .husky/_/post-rewrite:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/commit-msg
--------------------------------------------------
Content of .husky/_/commit-msg:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-push
--------------------------------------------------
Content of .husky/_/pre-push:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/post-merge
--------------------------------------------------
Content of .husky/_/post-merge:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: .husky/_/pre-commit
--------------------------------------------------
Content of .husky/_/pre-commit:
#!/usr/bin/env sh
. "$(dirname "$0")/h"

File: tests/auth.validation.test.ts
--------------------------------------------------
Content of tests/auth.validation.test.ts:
import { AuthSchema, RegisterSchema } from "@/entities/auth/auth.dto";

describe("Auth Validation", () => {
  describe("Login Schema", () => {
    it("should pass with valid email and password", async () => {
      const validData = { email: "test@example.com", password: "Password123!" };
      await expect(AuthSchema.parseAsync(validData)).resolves.toEqual(validData);
    });

    it("should fail with missing email", async () => {
      const invalidData = { password: "Password123!" };
      try {
        await AuthSchema.parseAsync(invalidData);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } catch (err: any) {
        expect(err.errors).toEqual([
          {
            code: "invalid_type",
            expected: "string",
            received: "undefined",
            path: ["email"],
            message: "Required",
          },
        ]);
      }
    });

    it("should fail with invalid email format", async () => {
      const invalidData = { email: "not-an-email", password: "Password123!" };
      try {
        await AuthSchema.parseAsync(invalidData);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } catch (err: any) {
        expect(err.errors).toEqual([
          {
            code: "invalid_string",
            validation: "email",
            path: ["email"],
            message: "Invalid email",
          },
        ]);
      }
    });

    describe("Register Schema", () => {
      it("should pass with valid email, password, and confirmPassword", async () => {
        const validData = {
          email: "test@example.com",
          name: "Test User",
          username: "testuser",
          password: "Password123!",
          confirmPassword: "Password123!",
        };
        await expect(RegisterSchema.parseAsync(validData)).resolves.toEqual(validData);
      });

      it("should fail when passwords do not match", async () => {
        const invalidData = {
          email: "test@example.com",
          name: "Test User",
          username: "testuser",
          password: "Password123!",
          confirmPassword: "DifferentPassword!",
        };
        try {
          await RegisterSchema.parseAsync(invalidData);
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        } catch (err: any) {
          expect(err.errors).toEqual([
            {
              code: "custom",
              path: ["confirmPassword"],
              message: "Passwords don't match",
            },
          ]);
        }
      });
    });
  });
});


File: .vscode/launch.json
--------------------------------------------------
Content of .vscode/launch.json:
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "program": "${workspaceFolder}/src/app.ts",
            "outFiles": [
                "${workspaceFolder}/**/*.js"
            ]
        }
    ]
}

File: src/.DS_Store
--------------------------------------------------
Error reading file: 'utf-8' codec can't decode byte 0xff in position 1072: invalid start byte. Content skipped.


File: src/app.ts
--------------------------------------------------
Content of src/app.ts:
import { errorMiddleware, cors } from "@/middlewares";
import express, { NextFunction, Request, Response } from "express";
import { apiRoutes } from "@/routes/routes";
import { env } from "@/config/env";
import { logger, morganStream } from "@/common/winston/winston";
import { openAPIRouter } from "@/common/swagger/swagger.router";
import { slowDown } from "express-slow-down";
import compression from "compression";
import cookieParser from "cookie-parser";
import helmet from "helmet";
import hpp from "hpp";
import morgan from "morgan";
import nocache from "nocache";
import path from "node:path";
import rateLimit from "express-rate-limit";
import responseTime from "response-time";
import timeout from "connect-timeout";

const app = express();

// Set the trust proxy to handle X-Forwarded-For correctly
app.set("trust proxy", 1);

// Middlewares
app.use(
  helmet.crossOriginResourcePolicy({
    policy: "cross-origin",
  }),
);

// Additional Security Headers
app.use((_, res: Response, next: NextFunction) => {
  res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("X-XSS-Protection", "1; mode=block");
  // Cross-Domain Policy
  res.setHeader("X-Permitted-Cross-Domain-Policies", "none");
  res.setHeader("X-Download-Options", "noopen");
  // Feature Policy
  res.setHeader("Feature-Policy", "geolocation 'none'; microphone 'none'; camera 'none';");
  // Expect-CT Header
  res.setHeader("Expect-CT", "enforce, max-age=30");

  next();
});
logger.info("Additional security headers set");

// Rate limiting middleware
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 500, // Limit each IP to 500 requests per windowMs
  message: {
    success: false,
    message: "Too many requests, please try again later.",
  },
  headers: true,
});

// Slow down requests from a single IP to prevent abuse
const speedLimiter = slowDown({
  windowMs: 15 * 60 * 1000, // 15 minutes
  delayAfter: 1000, // Allow 1000 requests, then start delaying
  delayMs: (hits) => hits * 500, // Add a 500ms delay per request above 1000
});

// Apply middlewares
app.use(cors); // Make sure this middleware is defined properly
logger.info("CORS middleware applied");
app.use(cookieParser());

if (env.ENABLE_WINSTON === "1") {
  app.use(morgan("dev", { stream: morganStream }));
} else {
  app.use(morgan("dev"));
}

app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(compression());
app.use(nocache()); // Prevent caching
app.use(hpp());
app.use(limiter);
logger.info("Rate limiting middleware applied");
app.use(speedLimiter);
logger.info("Speed limiting middleware applied");

// Response Time Middleware
app.use(responseTime());
logger.info("Response time middleware applied");

// Timeout Middleware
app.use(timeout(env.SERVER_TIMEOUT)); // Set a 150-second timeout for all routes
logger.info("Timeout middleware applied"); // Log timeout middleware

// Permissions Policy
logger.info("Permissions policy applied"); // Log permissions policy setup
app.use((_, res, next) => {
  res.append("Permissions-Policy", "browsing-topics=()");
  next();
});

// Routes
app.use("/uploads", express.static(path.join(__dirname, "../uploads")));
logger.info("Uploads routes set up");

app.use("/logs", express.static(path.join(__dirname, "../logs")));
logger.info("Logs routes set up");

app.use("/api", apiRoutes);
logger.info("API routes set up");

// Swagger UI
app.use(openAPIRouter);
logger.info("Swagger UI routes set up");

// Custom Error Handler Middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  errorMiddleware(err, req, res, next);
});

// Catch 404 and forward to error handler
app.use((_: Request, res: Response) => {
  logger.warn("Route not found");
  res.status(404).send("Route not found");
});

export default app;


File: src/server.ts
--------------------------------------------------
Content of src/server.ts:
import app from "@/app";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import { connectMongoDB } from "@/config/mongodb/mongodb";
import { checkMongoDB, checkRedis } from "@/entities/health/health.helper";

const { PORT, NODE_ENV, BASE_URL, ALLOW_ORIGIN } = env;

/**
 * Function to check the connection status for Redis, and MongoDB.
 * Logs the success or failure of each connection check.
 */
async function checkConnections() {
  try {
    logger.info("Checking database connections...");
    await checkRedis();
    logger.info("Redis connections verified successfully.");
    await connectMongoDB();
    await checkMongoDB();
    logger.info("MongoDB connections verified successfully.");
  } catch (error) {
    if (error instanceof Error) {
      logger.warn("MongoDB, or Redis connection failed", { error: error.message });
    } else {
      logger.warn("Unknown error occurred during connection checks");
    }

    // eslint-disable-next-line no-process-exit
    process.exit(1); // Exit the process if any connection check fails
  }
}

/**
 * Function to start the server and handle termination signals (SIGINT, SIGTERM).
 * Logs the server status on startup and graceful shutdown.
 */
checkConnections().then(() => {
  const server = app.listen(PORT, () =>
    logger.info(
      `Server running on PORT: ${PORT}, ==> ENV: ${NODE_ENV}, ==> API: ${BASE_URL}, ==> ALLOW_ORIGIN: ${ALLOW_ORIGIN}`,
    ),
  );

  const onCloseSignal = () => {
    logger.info("SIGTERM signal received. Closing server...");
    server.close(() => {
      logger.info("HTTP server closed.");
      // eslint-disable-next-line no-process-exit
      process.exit(); // Ensure the process exits after server closure
    });
  };

  process.on("SIGINT", onCloseSignal); // Gracefully handle SIGINT (Ctrl+C or control+C)
  process.on("SIGTERM", onCloseSignal); // Gracefully handle SIGTERM (from Docker, etc.)
});


File: src/types/pagination.ts
--------------------------------------------------
Content of src/types/pagination.ts:
export interface FilterCondition {
  $eq?: string | number;
  $regex?: string;
  $between?: [string | number, string | number];
  $gte?: number;
  $lte?: number;
  $isNull?: boolean;
  $isNotNull?: boolean;
}

export type Filter = Record<string, FilterCondition>;

export interface LogicalFilter {
  $and?: Filter[];
  $or?: Filter[];
}

export interface OrderBy {
  sort: string;
  order: "asc" | "desc";
}

export interface Paginate {
  page: number;
  perPage: number;
}

export interface QueryOptions {
  filter?: Filter;
  paginate?: Paginate;
  orderBy?: OrderBy[];
}

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  perPage: number;
}


File: src/types/request.ts
--------------------------------------------------
Content of src/types/request.ts:
import { Request } from "express";

export interface CustomRequest extends Request {
  loggedUser?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  file?: any;
}


File: src/config/env.ts
--------------------------------------------------
Content of src/config/env.ts:
import dotenv from "dotenv";
import { z } from "zod";

dotenv.config();

const envSchema = z.object({
  NODE_ENV: z.enum(["local", "development", "test", "production"]).default("local"),
  TZ: z.string().default("UTC"),
  BASE_URL: z.string().url(),
  BASE_URL_HTTPS: z.string().url().optional(),
  PORT: z.string().transform((val) => parseInt(val, 10)),
  SERVER_TIMEOUT: z.string().default("150s"),
  LOG_FILE_DURATION: z.string().default("3d"),
  ALLOW_ORIGIN: z.string(),
  APP_URL: z.string().url(),
  LOGS_DIRECTORY: z.string(),

  // Redis Configuration
  REDIS_URL: z.string(),

  // Basic Auth Secrets
  JWT_SECRET: z.string(),
  JWT_SECRET_EXPIRATION: z.string(),
  HASH: z.string().transform((val) => parseInt(val, 10)),

  MONGODB_URI: z.string().url(),
  ENABLE_WINSTON: z.enum(["0", "1"]).default("0"),
  ENABLE_LOGS: z.enum(["0", "1"]).default("0"),
  ENABLE_ERROR_LOGS: z.enum(["0", "1"]).default("0"),
  LOGS_TYPE: z.enum(["mongodb", "directory"]).default("mongodb"),
  MONGODB_ERROR_COLLECTION_NAME: z.string(),
  MONGODB_MEMORY_LIMIT: z.string().default("512"),

  // Mail sender
  MAILGUN_API_KEY: z.string().optional(),
  MAILGUN_DOMAIN: z.string().optional(),
  MAILGUN_SENDER_EMAIL: z.string().optional(),
  MAILGUN_NAME: z.string().optional(),
});

export const env = envSchema.parse(process.env);


File: src/config/redis/redis.ts
--------------------------------------------------
Content of src/config/redis/redis.ts:
import Redis from "ioredis";
import { env } from "@/config/env";
const redis = new Redis(env.REDIS_URL);

export default redis;


File: src/config/mongodb/mongodb.ts
--------------------------------------------------
Content of src/config/mongodb/mongodb.ts:
import mongoose from "mongoose";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import ErrorLogs from "@/models/error-logs";

export const connectMongoDB = async () =>
  mongoose.connect(env.MONGODB_URI, {
    dbName: env.NODE_ENV,
  });

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const checkMemoryAndLog = async (logData: any) => {
  try {
    if (!mongoose.connection.readyState) {
      await mongoose.connect(env.MONGODB_URI, {
        dbName: env.NODE_ENV,
      });
    }

    const stats = await mongoose.connection.db!.stats();
    const dbUsage = stats.dataSize / (1024 * 1024);
    const dbLimit = Number(env.MONGODB_MEMORY_LIMIT);

    logger.info(`Database usage: ${dbUsage.toFixed(2)} MB of ${dbLimit} MB`);

    if (dbUsage < dbLimit / 2) {
      const log = new ErrorLogs(env.MONGODB_ERROR_COLLECTION_NAME, logData);
      await log.save();
    } else {
      logger.warn(`Database usage: ${dbUsage.toFixed(2)} MB of ${dbLimit} MB`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("MongoDB Error:", error);
  } finally {
    if (mongoose.connection.readyState) {
      await mongoose.disconnect();
    }
  }
};


File: src/template/forgot-password.hbs
--------------------------------------------------
Content of src/template/forgot-password.hbs:
<html
  xmlns:v="urn:schemas-microsoft-com:vml"
  xmlns:o="urn:schemas-microsoft-com:office:office"
  lang="en"
>

  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reset password requested</title>
    <style>
      .email-container * { font-family: 'Barlow'; font-size: 16px; } p { font-family: 'Barlow';
      font-style: normal; font-weight: 400; font-size: 18px; line-height: 24px; color: #181920; }
      .button-reset { max-width: 120px; text-decoration: none; cursor: pointer; font-size:
      16px;padding: 10px 20px; position: absolute; height: 44px; background: #36854C; border-radius:
      50px; border: none; }
    </style>
  </head>

  <body>
    <div class="email-container" style="padding-left: 10px; padding-top: 10px;">
      <p style="text-transform: capitalize;">Hi {{accountName}},</p>
      <p>We received a request to reset the password for your account.</p>
      <p>To reset your Password, click on the button below:</p>
      <a
        class="button-reset"
        href="{{URL}}"
        style="font-weight:700;color:#ffffff;max-width: 120px;justify-content: center;align-items: center;"
      >
        Reset Password
      </a>
      <br />
      <br />
      <p style="margin-bottom: 30px;">Or copy and paste the URL into your browser:</p>
      <a href="{{URL}}">{{URL}}</a>
      <br />
      <br />
      <p>If you did not request a password reset, please ignore this email or reply to let us know.</p>
      <p>This password reset link is only valid for 10 minutes.</p>
      <br />
      <p>Thank you,</p>
      <p>The Bulletproof Team</p>
    </div>
  </body>
</html>

File: src/template/create-template.ts
--------------------------------------------------
Content of src/template/create-template.ts:
import fs from "fs";
import path from "path";
import handlebars from "handlebars";
import juice from "juice";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function createTemplate(name: string, context: any) {
  if (!/^[a-zA-Z0-9-_]+$/.test(name)) {
    throw new Error("Invalid template name");
  }

  const templatePath = path.join(__dirname, `${name}.hbs`);

  if (!fs.existsSync(templatePath)) {
    throw new Error("Template not found");
  }

  const source = fs.readFileSync(templatePath, "utf8");
  const template = handlebars.compile(source);
  const html = template(context);
  return juice(html);
}


File: src/middlewares/auth-middleware.ts
--------------------------------------------------
Content of src/middlewares/auth-middleware.ts:
import { NextFunction, Response } from "express";
import { CustomRequest } from "@/types/request";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { verifyToken } from "@/common/jwt/jwt";
import { winstonLogger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const authMiddleware = (req: CustomRequest, _: Response, next: NextFunction): any => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) {
    throw createHttpError(StatusCodes.UNAUTHORIZED, "Unauthorized", {
      resource: "Auth Middleware",
    });
  }

  const verify = verifyToken(token);
  req.loggedUser = verify.email || verify.username || verify.type;
  winstonLogger.defaultMeta = { loggedUser: verify.email || verify.username || verify.type };
  next();
};


File: src/middlewares/error-middleware.ts
--------------------------------------------------
Content of src/middlewares/error-middleware.ts:
import { NextFunction, Response } from "express";
import { HttpError } from "http-errors";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { checkMemoryAndLog } from "@/config/mongodb/mongodb";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const transformMetaData = (metadata: any) => {
  if (!metadata) {
    return "";
  }

  // Extract common properties
  const { code, meta, name, response } = metadata;

  return {
    code,
    meta: { ...meta },
    data: { ...response?.data },
    status: response?.status,
    statusText: response?.statusText,
    name,
  };
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const findDeep = (obj: any, keys: string[]): any => {
  if (!obj || typeof obj !== "object") {
    return null;
  }
  for (const key of keys) {
    if (key in obj) {
      return obj[key];
    }
  }
  for (const value of Object.values(obj)) {
    const found = findDeep(value, keys);
    if (found) {
      return found;
    }
  }
  return null;
};

/**
 * Error middleware for catching and logging errors.
 *
 * Params:
 * - err: The error object (could be a HttpError or general error).
 * - req: The request object (with optional user data).
 * - res: The response object.
 * - _: The NextFunction (unused in this case).
 *
 * Response:
 * - Responds with the appropriate status code and error message in the response.
 * - If not in production, detailed error info is included (method, URL, stack trace).
 */
export const errorMiddleware = (
  err: Error | HttpError,
  req: CustomRequest,
  res: Response,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _: NextFunction,
): Response => {
  const { message, ...details } = err;
  const isHttpError = err instanceof HttpError;

  const statusCode = isHttpError
    ? err.status || StatusCodes.INTERNAL_SERVER_ERROR
    : StatusCodes.INTERNAL_SERVER_ERROR;

  const name = isHttpError ? err.name : "AppError";

  const loggedUser = req.loggedUser || "Unknown User";
  const { method } = req;
  const url = req.originalUrl;

  const { stack } = err;

  // Extract email or id using the helper function
  const email = findDeep(req.body, ["email"]);
  const id = findDeep(req.body, ["id"]);

  const transformDetails = { ...transformMetaData(details), email, id };

  const errorPayload = {
    status: statusCode,
    message: message.trim(),
    method,
    url,
    loggedUser,
    name,
    details: transformDetails,
    stack,
  };

  logger.error(errorPayload.message, errorPayload);

  if (env.ENABLE_WINSTON !== "1" && env.ENABLE_ERROR_LOGS === "1") {
    const errorLogs = {
      level: "error",
      message,
      timestamp: new Date().toISOString(),
      metadata: errorPayload,
    };

    checkMemoryAndLog(errorLogs)
      // eslint-disable-next-line no-empty-function
      .then(() => {})
      .catch((error) => {
        logger.error("Error saving error logs", error);
      });
  }

  const responsePayload = {
    status: statusCode,
    message: message.trim(),
    ...(env.NODE_ENV !== "production" && {
      method,
      url,
      loggedUser,
      name,
      details: transformDetails,
      stack,
    }),
  };

  return res.status(statusCode).json(responsePayload);
};


File: src/middlewares/index.ts
--------------------------------------------------
Content of src/middlewares/index.ts:
export { cors } from "@/middlewares/cors";
export { authMiddleware } from "@/middlewares/auth-middleware";
export { errorMiddleware } from "@/middlewares/error-middleware";
export { zodValidation } from "@/middlewares/zod-validation";


File: src/middlewares/cors.ts
--------------------------------------------------
Content of src/middlewares/cors.ts:
import corsLibrary from "cors";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

const allowedOrigins = (env.ALLOW_ORIGIN || "").split(",");

/**
 * CORS configuration to check allowed origins and set the appropriate headers
 *
 * Params:
 * - origin (string | undefined): Origin of the request, or undefined if not present.
 * - callback (function): Callback to confirm if origin is allowed or not.
 *
 * Response:
 * - Calls the callback with null and true if origin is allowed, otherwise calls callback with an error.
 */
export const config = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  origin: (origin: string | undefined, callback: any) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      logger.warn("Origin not allowed by CORS", { origin });

      callback(new Error("Not allowed by CORS"));
    }
  },
  optionsSuccessStatus: StatusCodes.OK,
  methods: "GET,HEAD,OPTIONS,PUT,POST,DELETE",
  credentials: true,
  exposedHeaders: ["Content-Type", "set-cookie"],
  options: {
    "Access-Control-Allow-Origin": env.ALLOW_ORIGIN || "*",
    "Access-Control-Allow-Headers": "Origin, X-Requested-With, Content-Type, Accept",
    "Access-Control-Allow-Methods": "GET,HEAD,OPTIONS,PUT,POST,DELETE",
  },
};

// Initialize the CORS middleware with the configured settings
export const cors = corsLibrary(config);

export default { cors, config };


File: src/middlewares/zod-validation.ts
--------------------------------------------------
Content of src/middlewares/zod-validation.ts:
import { NextFunction, Request, Response } from "express";
import { StatusCodes } from "http-status-codes";
import { ZodTypeAny } from "zod";
import { logger } from "@/common/winston/winston";
import { createResponse } from "@/utils/create-response";

export const zodValidation =
  (zSchema: ZodTypeAny) =>
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async (req: Request, res: Response, next: NextFunction): Promise<any> => {
    try {
      const data = zSchema.parse(req.body);
      if (data) {
        req.body = data;
        next();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn("Zod Validation Error", error);
      return res
        .status(StatusCodes.BAD_REQUEST)
        .json(createResponse(req, error, "Zod Validation Error", StatusCodes.BAD_REQUEST));
    }
  };


File: src/utils/create-response.ts
--------------------------------------------------
Content of src/utils/create-response.ts:
import { Request } from "express";
import { StatusCodes, ReasonPhrases } from "http-status-codes";

export const createResponse = (
  req: Request,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data: any,
  message: string = ReasonPhrases.OK,
  status: number = StatusCodes.OK,
) => {
  return {
    status,
    message,
    method: req.method,
    url: req.originalUrl,
    data,
  };
};


File: src/utils/utils.ts
--------------------------------------------------
Content of src/utils/utils.ts:
export const generatePassword = (): string => {
  const getRandomChar = (characters: string): string =>
    characters[Math.floor(Math.random() * characters.length)];

  const categories = [
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ", // Uppercase letters
    "abcdefghijklmnopqrstuvwxyz", // Lowercase letters
    "0123456789", // Digits
    "!@#$%^&*()_-+=<>?/", // Special characters
  ];

  const password = categories.map(getRandomChar).join("");

  const remainingLength = Number(process.env.BP_GENERATED_PASSWORD_LENGTH || 10) - password.length;
  const allCharacters = categories.join("");
  const randomChars = Array.from({ length: remainingLength }, () => getRandomChar(allCharacters));

  console.log(`Generated Password ==> ${password + randomChars.join("")}`);
  return password + randomChars.join("");
};

export const extractDomainFromEmailAddress = (email: string): string | null => {
  const match = email.match(/@([\w.-]+)/);
  if (!match) {
    return null;
  }

  return match[1].toLowerCase();
};

File: src/utils/csv-to-json.ts
--------------------------------------------------
Content of src/utils/csv-to-json.ts:
import * as fs from "fs";
import csv from "csv-parser";
import { Readable } from "stream";
import { v4 as uuidv4 } from "uuid";
import _ from "lodash";
import { hash } from "bcrypt";
import { env } from "@/config/env";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const transformData = async (value: string, key?: string): Promise<any> => {
  if (key?.toLowerCase() === "password") {
    try {
      return await hash(value, env.HASH!);
    } catch (error) {
      logger.info(`Error hashing password: ${error}`);
      throw new Error(`Error hashing password: ${error}`);
    }
  }
  if (value === "NULL") {
    return null;
  }
  if (value === "FALSE") {
    return false;
  }
  if (value === "TRUE") {
    return true;
  }
  if (value === "UNDEFINED") {
    return undefined;
  }
  return value;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const sanitizeEntry = ([key, value]: [string, any]): [string, any] => {
  const sanitizedKey = _.trim(_.toLower(key.replace(/\s+/g, "")));
  const sanitizedValue = _.trim(value);
  return [sanitizedKey, sanitizedValue];
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const csvToJson = (filePath: string): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result: any[] = [];
    const stream = fs.createReadStream(filePath);

    stream
      .pipe(csv())
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on("data", (row: Record<string, any>) => {
        result.push(
          Object.entries(row).reduce(
            (acc, entry) => {
              const [sanitizedKey, sanitizedValue] = sanitizeEntry(entry);
              acc[sanitizedKey] = transformData(sanitizedValue, sanitizedKey); // Collect promises
              return acc;
            },
            {
              uuid: uuidv4(),
              createdAt: new Date(),
              updatedAt: new Date(),
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } as Record<string, any>,
          ),
        );
      })
      .on("end", async () => {
        try {
          // Wait for all promises to resolve
          const resolvedResults = await Promise.all(
            result.map(async (row) => {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const resolvedRow: Record<string, any> = {};
              for (const [key, value] of Object.entries(row)) {
                // eslint-disable-next-line no-await-in-loop
                resolvedRow[key] = await value;
              }
              return resolvedRow;
            }),
          );
          resolve(resolvedResults);
        } catch (err) {
          reject(err);
        } finally {
          fs.unlinkSync(filePath);
        }
      })
      .on("error", (error) => {
        reject(error);
        fs.unlinkSync(filePath);
      });
  });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const csvBufferToJson = (buffer: string): Promise<any[]> => {
  return new Promise((resolve, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result: any[] = [];
    const stream = Readable.from(buffer.toString());

    stream
      .pipe(csv())
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .on("data", (row: Record<string, any>) => {
        result.push(
          Object.entries(row).reduce(
            (acc, entry) => {
              const [sanitizedKey, sanitizedValue] = sanitizeEntry(entry);
              acc[sanitizedKey] = transformData(sanitizedValue, sanitizedKey); // Collect promises
              return acc;
            },
            {
              uuid: uuidv4(),
              createdAt: new Date(),
              updatedAt: new Date(),
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } as Record<string, any>,
          ),
        );
      })
      .on("end", async () => {
        try {
          // Wait for all promises to resolve
          const resolvedResults = await Promise.all(
            result.map(async (row) => {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const resolvedRow: Record<string, any> = {};
              for (const [key, value] of Object.entries(row)) {
                // eslint-disable-next-line no-await-in-loop
                resolvedRow[key] = await value;
              }
              return resolvedRow;
            }),
          );
          resolve(resolvedResults);
        } catch (err) {
          reject(err);
        }
      })
      .on("error", (err) => reject(err));
  });
};


File: src/utils/mongodb-apply-filter.ts
--------------------------------------------------
Content of src/utils/mongodb-apply-filter.ts:
import { FilterQuery } from "mongoose";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const mongoDbApplyFilter = (filter: Record<string, any>): FilterQuery<any> => {
  if (!filter) {
    return {};
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const transformOperators = (key: string, value: any) => {
    const operatorMap: Record<string, string> = {
      $eq: "$eq",
      $regex: "$regex",
      $between: "$gte",
      $gte: "$gte",
      $lte: "$lte",
      $isNull: "$exists",
      $isNotNull: "$exists",
    };

    if (key === "$between") {
      return {
        $gte: value[0],
        $lte: value[1],
      };
    }

    if (key === "$isNull") {
      return { $exists: false };
    }

    if (key === "$isNotNull") {
      return { $exists: true };
    }

    return { [operatorMap[key]]: value };
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const buildLogic = (logic: Record<string, any>) => {
    const logicKeys = Object.keys(logic);
    return logicKeys.map((key) => {
      const condition = logic[key];
      if (Array.isArray(condition)) {
        return { [key]: condition.map(mongoDbApplyFilter) };
      }
      return { [key]: transformOperators(key, condition) };
    });
  };

  if (filter.$or || filter.$and) {
    const logicKey = filter.$or ? "$or" : "$and";
    return {
      [logicKey]: buildLogic(filter[logicKey]),
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const transformedFilter: Record<string, any> = {};
  Object.entries(filter).forEach(([key, value]) => {
    if (typeof value === "object" && !Array.isArray(value)) {
      transformedFilter[key] = transformOperators(Object.keys(value)[0], Object.values(value)[0]);
    } else {
      transformedFilter[key] = value;
    }
  });

  return transformedFilter;
};


File: src/models/error-logs.ts
--------------------------------------------------
Content of src/models/error-logs.ts:
import { env } from "@/config/env";
import mongoose, { Document, Schema } from "mongoose";

export interface ErrorLogs extends Document {
  level: string;
  message: string;
  timestamp: Date;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  metadata: any;
}

const ErrorLogsSchema: Schema = new Schema(
  {
    level: { type: String },
    message: { type: String },
    timestamp: { type: Date },
    metadata: { type: Schema.Types.Mixed },
  },
  {
    strict: false,
  },
);

export default mongoose.model<ErrorLogs>(env.NODE_ENV, ErrorLogsSchema);


File: src/schemas/query-examples.txt
--------------------------------------------------
Content of src/schemas/query-examples.txt:
1. Simple Equality Filter
{
  "filter": {
    "data.number": { "$eq": "12345" }
  },
  "paginate": {
    "page": 1,
      "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" }
  ]
}

2. Case-Insensitive Text Search
{
  "filter": {
    "data.email": { "$regex": "test" }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.email", "order": "desc" }
  ]
}

3. Range Filter
json
{
  "filter": {
    "data.age": { "$between": [25, 35] }
  },
  "paginate": {
    "page": 2,
    "perPage": 20
  },
  "orderBy": [
    { "sort": "data.age", "order": "asc" }
  ]
}

4. Null and Not Null Filters
{
  "filter": {
    "data.address": { "$isNull": true }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.id", "order": "asc" }
  ]
}
{
  "filter": {
    "data.phone": { "$isNotNull": true }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.phone", "order": "asc" }
  ]
}

5. Combining $or and $and
{
  "filter": {
    "$or": [
      {
        "$and": [
          { "data.number": { "$eq": "12345" } },
          { "data.email": { "$regex": "test" } }
        ]
      },
      {
        "data.age": { "$gte": 30 }
      }
    ]
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" }
  ]
}

6. Using $and with Multiple Conditions
{
  "filter": {
    "$and": [
      { "data.status": { "$eq": "active" } },
      { "data.created_at": { "$between": ["2024-01-01", "2024-12-31"] } }
    ]
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.created_at", "order": "desc" }
  ]
}

7. $or Condition with Multiple Filters
{
  "filter": {
    "$or": [
      { "data.name": { "$regex": "john" } },
      { "data.email": { "$regex": "example" } },
      { "data.age": { "$lt": 30 } }
    ]
  },
  "paginate": {
    "page": 3,
    "perPage": 15
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.age", "order": "desc" }
  ]
}

8. Filter with Multiple $and and $or Combinations
{
  "filter": {
    "$and": [
      {
        "$or": [
          { "data.city": { "$eq": "New York" } },
          { "data.city": { "$eq": "Los Angeles" } }
        ]
      },
      { "data.status": { "$eq": "verified" } },
      {
        "$or": [
          { "data.age": { "$gte": 25 } },
          { "data.email": { "$regex": "test" } }
        ]
      }
    ]
  },
  "paginate": {
    "page": 2,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.city", "order": "asc" },
    { "sort": "data.age", "order": "desc" }
  ]
}

9. Sorting by Multiple Columns
{
  "filter": {
    "data.status": { "$eq": "active" }
  },
  "paginate": {
    "page": 1,
    "perPage": 10
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.created_at", "order": "desc" }
  ]
}

10. Combining All Features
{
  "filter": {
    "$and": [
      { "data.status": { "$eq": "active" } },
      {
        "$or": [
          { "data.number": { "$eq": "12345" } },
          { "data.email": { "$regex": "test" } }
        ]
      },
      { "data.age": { "$between": [20, 30] } },
      { "data.address": { "$isNotNull": true } }
    ]
  },
  "paginate": {
    "page": 4,
    "perPage": 20
  },
  "orderBy": [
    { "sort": "data.name", "order": "asc" },
    { "sort": "data.age", "order": "desc" },
    { "sort": "data.created_at", "order": "asc" }
  ]
}

File: src/schemas/find-by-query.ts
--------------------------------------------------
Content of src/schemas/find-by-query.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

// See query examples in query-examples.txt

const OrderBySchema = z.object({
  sort: z.string(),
  order: z.enum(["asc", "desc"]),
});

const PaginateSchema = z.object({
  page: z.number().min(1).default(1),
  perPage: z.number().min(1).default(10),
});

export const FindByQuerySchema = z.object({
  filter: z.any(),
  paginate: PaginateSchema.optional(),
  orderBy: z.array(OrderBySchema).optional(),
});

export type FindByQueryDto = z.infer<typeof FindByQuerySchema>;


File: src/schemas/import-file.ts
--------------------------------------------------
Content of src/schemas/import-file.ts:
import { z } from "zod";

export const ImportFileSchema = z.object({
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload"),
});


File: src/common/jwt/jwt.ts
--------------------------------------------------
Content of src/common/jwt/jwt.ts:
import { sign, verify } from "jsonwebtoken";
import { env } from "@/config/env";
import { StatusCodes } from "http-status-codes";
import createHttpError from "http-errors";

export const generateToken = (payload: object) => {
  return sign(payload, env.JWT_SECRET, { expiresIn: env.JWT_SECRET_EXPIRATION });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const verifyToken = (token: string): any => {
  try {
    return verify(token, env.JWT_SECRET);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (error) {
    throw createHttpError(StatusCodes.FORBIDDEN, "Invalid or expired token", {
      resource: "Auth Middleware",
    });
  }
};


File: src/common/repository/repository.ts
--------------------------------------------------
Content of src/common/repository/repository.ts:
import { Model, UpdateQuery, SortOrder, RootFilterQuery } from "mongoose";
import { FindByQueryDto } from "@/schemas/find-by-query";
import { logger } from "@/common/winston/winston";
import { mongoDbApplyFilter } from "@/utils/mongodb-apply-filter";

const IGNORE_FIELDS = { password: 0 };
export class GenericRepository<T, TCreateDto, TUpdateDto> {
  private model: Model<T>;
  private logFileName: string;

  constructor(model: Model<T>, logFileName: string) {
    this.logFileName = logFileName;
    this.model = model;
  }

  /**
   * Fetches all entities from the collection.
   * @returns Array of entities
   */
  getAll = async (): Promise<T[]> => {
    try {
      logger.info(`${this.logFileName} Fetching all from ${this.model.modelName}`);
      return await this.model.find({}, IGNORE_FIELDS);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error fetching all from ${this.model.modelName}`, {
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Fetches an entity by ID.
   * @param id - Entity's unique identifier
   * @returns Entity data or null if not found
   */
  getById = async (id: string): Promise<T | null> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.model.modelName} with id: ${id}`);
      return await this.model.findById(id, IGNORE_FIELDS);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error fetching ${this.model.modelName} by id`, {
        id,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Fetches a entity by their id.
   * @param uuid - entity's unique identifier
   * @returns entity data or null if not found
   */
  getByUuid = async (uuid: string): Promise<T | null> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.model.modelName} with uuid: ${uuid}`);
      return await this.model.findOne({ uuid }, IGNORE_FIELDS);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error fetching ${this.model.modelName} by uuid`, {
        uuid,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Fetches a entity by their email.
   * @param email - entity's email
   * @returns entity data or null if not found
   */
  getByEmail = async (email: string): Promise<T | null> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.model.modelName} with email: ${email}`);
      return await this.model.findOne({ email }, IGNORE_FIELDS);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error fetching ${this.model.modelName} by email`, {
        email,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Fetches a entity by their username.
   * @param username - entity's username
   * @returns entity data or null if not found
   */
  getByUsername = async (username: string): Promise<T | null> => {
    try {
      logger.info(
        `${this.logFileName} Fetching ${this.model.modelName} with username: ${username}`,
      );
      return await this.model.findOne({ username }, IGNORE_FIELDS);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error fetching ${this.model.modelName} by username`, {
        username,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Fetches a document based on a specified field and its value.
   * @param field - The field name to search by.
   * @param value - The value to match for the specified field.
   * @returns The matched document or null if not found.
   */
  getByField = async (field: string, value: string | number): Promise<T | null> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.model.modelName} where ${field}: ${value}`);
      const query = { [field]: value };
      return await this.model.findOne(query as RootFilterQuery<T>, IGNORE_FIELDS);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error fetching ${this.model.modelName} by ${field}`, {
        field,
        value,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Finds entities with pagination.
   * @param options - Query options
   * @returns Paginated data
   */
  findByQuery = async (options: FindByQueryDto) => {
    const { filter = {}, paginate = { page: 1, perPage: 10 }, orderBy = [] } = options;

    const { page, perPage } = paginate;

    try {
      // Build the sort object for MongoDB
      const sortOptions = orderBy.reduce(
        (acc, { sort, order }) => {
          acc[sort] = order;
          return acc;
        },
        {} as Record<string, SortOrder>,
      );

      // Convert the filter for MongoDB
      const mongoFilter = mongoDbApplyFilter(filter);

      // Query the collection
      const [data, total] = await Promise.all([
        this.model
          .find(mongoFilter, IGNORE_FIELDS)
          .sort(sortOptions)
          .skip((page - 1) * perPage)
          .limit(perPage)
          .exec(),
        this.model.countDocuments(mongoFilter),
      ]);

      return {
        data,
        total,
        page,
        perPage,
        totalPages: Math.ceil(total / perPage),
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error querying ${this.model.modelName}`, {
        options,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  create = async (createDto: TCreateDto): Promise<any> => {
    try {
      logger.info(`${this.logFileName} Creating document in ${this.model.modelName}`);
      const created = new this.model(createDto);
      await created.save();
      return this.getById(created.id);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error creating entry in ${this.model.modelName}`, {
        createDto,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Updates an existing entity.
   * @param uuid - Entity's unique identifier
   * @param updateDto - Data to update the entity
   * @returns Updated entity data
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (uuid: string, updateDto: TUpdateDto): Promise<any> => {
    try {
      logger.info(`${this.logFileName} Updating ${this.model.modelName} with uuid: ${uuid}`);
      return await this.model.findOneAndUpdate({ uuid }, updateDto as UpdateQuery<T>, {
        new: true,
      });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error updating ${this.model.modelName}`, {
        uuid,
        updateDto,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Deletes an entity by uuid.
   * @param uuid - Entity's unique identifier
   * @returns Deleted entity data
   */
  delete = async (uuid: string): Promise<T | null> => {
    try {
      logger.info(`${this.logFileName} Deleting ${this.model.modelName} with uuid: ${uuid}`);
      return await this.model.findOneAndDelete({ uuid });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error deleting ${this.model.modelName}`, {
        uuid,
        error: error.message,
      });
      throw new Error(error);
    }
  };

  /**
   * Deletes multiple entities by their uuids.
   * @param uuids - List of entity uuids to delete
   * @returns Deletion result
   */
  async deleteAll(uuids: string[]): Promise<{ deletedCount: number }> {
    try {
      return await this.model.deleteMany({ uuid: { $in: uuids } });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error deleting multiple ${this.model.modelName}`, {
        uuids,
        error: error.message,
      });
      throw new Error(error);
    }
  }

  /**
   * Imports multiple entity objects into the database.
   * Skips objects where email or username already exist in the database.
   * @param entities - Array of entity objects to be saved
   * @returns Object containing created entities, created count, and skipped count
   */
  import = async (
    entities: TCreateDto[],
  ): Promise<{
    createdEntities: T[];
    createdCount: number;
    skippedCount: number;
  }> => {
    try {
      logger.info(
        `${this.logFileName} Importing ${entities.length} documents into ${this.model.modelName}`,
      );
      const uniqueEntities = [];
      const skippedEntities = [];

      for (const entity of entities) {
        // eslint-disable-next-line no-await-in-loop
        const exists = await this.model.exists({
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          $or: [{ email: (entity as any).email }, { username: (entity as any).username }],
        });

        if (exists) {
          logger.info(
            `${this.logFileName} Email or username already exist in ${this.model.modelName}`,
          );
          skippedEntities.push(entity);
        } else {
          uniqueEntities.push(entity);
        }
      }

      // Insert unique entities into the database
      const createdEntities = (await this.model.insertMany(uniqueEntities, {
        ordered: true,
      })) as unknown as T[];

      const createdCount = createdEntities.length;
      const skippedCount = skippedEntities.length;

      logger.info(`${this.logFileName} Import Summary:`, {
        createdCount,
        skippedCount,
        createdEntities,
      });

      return {
        createdEntities,
        createdCount,
        skippedCount,
      };

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (error: any) {
      logger.warn(`${this.logFileName} Error importing into ${this.model.modelName}`, {
        totalEntities: entities.length,
        error: error.message,
      });
      throw new Error(error);
    }
  };
}


File: src/common/swagger/swagger.router.ts
--------------------------------------------------
Content of src/common/swagger/swagger.router.ts:
import express, { type Request, type Response, type Router } from "express";
import { generateOpenAPIDocument } from "@/common/swagger/swagger-document-generator";
import swaggerUi from "swagger-ui-express";

export const openAPIRouter: Router = express.Router();
const openAPIDocument = generateOpenAPIDocument();

if (!["testing", "production"].includes(process.env.NODE_ENV!)) {
  openAPIRouter.get("/docs/swagger.json", (_req: Request, res: Response) => {
    res.setHeader("Content-Type", "application/json");
    res.send(openAPIDocument);
  });

  openAPIRouter.use("/docs", swaggerUi.serve, swaggerUi.setup(openAPIDocument));
}


File: src/common/swagger/swagger-response-builder.ts
--------------------------------------------------
Content of src/common/swagger/swagger-response-builder.ts:
import { ServiceResponseSchema } from "@/common/swagger/swagger-response";
import { StatusCodes } from "http-status-codes";
import type { z } from "zod";

export function createApiResponse(
  schema: z.ZodTypeAny,
  description: string,
  statusCode = StatusCodes.OK,
) {
  return {
    [statusCode]: {
      description,
      content: {
        "application/json": {
          schema: ServiceResponseSchema(schema),
        },
      },
    },
  };
}

// Use if you want multiple responses for a single endpoint

// Import { ResponseConfig } from '@asteasolutions/zod-to-openapi';
// Import { ApiResponseConfig } from '@common/models/openAPIResponseConfig';
// Export type ApiResponseConfig = {
//   Schema: z.ZodTypeAny;
//   Description: string;
//   StatusCode: StatusCodes;
// };
// Export function createApiResponses(configs: ApiResponseConfig[]) {
//   Const responses: { [key: string]: ResponseConfig } = {};
//   Configs.forEach(({ schema, description, statusCode }) => {
//     Responses[statusCode] = {
//       Description,
//       Content: {
//         'application/json': {
//           Schema: ServiceResponseSchema(schema),
//         },
//       },
//     };
//   });
//   Return responses;
// }


File: src/common/swagger/swagger-response.ts
--------------------------------------------------
Content of src/common/swagger/swagger-response.ts:
import { StatusCodes } from "http-status-codes";
import { z } from "zod";

export class ServiceResponse<T = null> {
  readonly success: boolean;
  readonly message: string;
  readonly responseObject: T;
  readonly statusCode: number;

  private constructor(success: boolean, message: string, responseObject: T, statusCode: number) {
    this.success = success;
    this.message = message;
    this.responseObject = responseObject;
    this.statusCode = statusCode;
  }

  // eslint-disable-next-line no-shadow
  static success<T>(message: string, responseObject: T, statusCode: number = StatusCodes.OK) {
    return new ServiceResponse(true, message, responseObject, statusCode);
  }

  // eslint-disable-next-line no-shadow
  static failure<T>(
    message: string,
    responseObject: T,
    statusCode: number = StatusCodes.BAD_REQUEST,
  ) {
    return new ServiceResponse(false, message, responseObject, statusCode);
  }
}

export const ServiceResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>
  z.object({
    success: z.boolean(),
    message: z.string(),
    responseObject: dataSchema.optional(),
    statusCode: z.number(),
  });


File: src/common/swagger/swagger-document-generator.ts
--------------------------------------------------
Content of src/common/swagger/swagger-document-generator.ts:
import { OpenAPIRegistry, OpenApiGeneratorV3 } from "@asteasolutions/zod-to-openapi";
import { env } from "@/config/env";
import { healthRegistry } from "@/entities/health/health.route";
import { authRegistry } from "@/entities/auth/auth.route";
import { usersRegistry } from "@/entities/users/users.route";
import { filesRegistry } from "@/entities/files/files.route";

export function generateOpenAPIDocument() {
  const registry = new OpenAPIRegistry([
    healthRegistry,
    authRegistry,
    usersRegistry,
    filesRegistry,
  ]);

  registry.registerComponent("securitySchemes", "bearerAuth", {
    type: "http",
    scheme: "bearer",
    bearerFormat: "JWT",
  });

  const generator = new OpenApiGeneratorV3(registry.definitions);

  return generator.generateDocument({
    openapi: "3.1.0",
    info: {
      version: "1.0.0",
      title: "Swagger API",
      description:
        "This is a simple CRUD API application made with Express and documented with Swagger",
      termsOfService: "http://swagger.io/terms/",
    },
    externalDocs: {
      description: "View the raw OpenAPI Specification in JSON format",
      url: "/swagger.json",
    },
    servers: [
      {
        url: `${env.BASE_URL}/api`,
        description: "http protocol",
      },
      ...(env.BASE_URL_HTTPS
        ? [
          {
            url: `${env.BASE_URL_HTTPS}/api`,
            description: "https protocol",
          },
        ]
        : []),
    ],
    security: [
      {
        bearerAuth: [],
      },
    ],
  });
}


File: src/common/constants/constants.ts
--------------------------------------------------
Content of src/common/constants/constants.ts:
export const BLACKLIST = {
  // "gmail.com": 1,
  // "outlook.com": 1,
  "comcast.net": 1,
  "aol.com": 1,
  // "yahoo.com": 1,
  // "ymail.com": 1,
  icloud: 1,
  "me.com": 1,
  "mac.com": 1,
  "hotmail.com": 1,
  // "bulletproofinbox.com": 1,
  "mg.bulletproofinbox.com": 1,
  "alerts.comcast.net": 1,
};


File: src/common/multer/multer.ts
--------------------------------------------------
Content of src/common/multer/multer.ts:
import { Request } from "express";
import multer from "multer";
import path from "path";
import fs from "fs";

//====================================================================================================

const storage = multer.memoryStorage();

const fileFilter = (_: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["image/jpeg", "image/png", "video/mp4", "video/mkv"];

  if (!allowedTypes.includes(file.mimetype)) {
    return cb(
      new Error("Invalid file type. Only images (JPEG, PNG) and videos (MP4, MKV) are allowed."),
    );
  }

  cb(null, true);
};

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
});

export const uploadMiddleware = upload.single("file");

//====================================================================================================

const importStorage = multer.diskStorage({
  destination: (_, __, cb) => {
    const uploadDir = "./uploads";
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }
    cb(null, uploadDir);
  },
  filename: (_, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    cb(null, `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`);
  },
});

const importFileFilter = (_: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ["text/csv"];

  if (!allowedTypes.includes(file.mimetype)) {
    return cb(new Error("Invalid file type. Only CSV file is allowed."));
  }

  cb(null, true);
};

const importUpload = multer({
  storage: importStorage,
  fileFilter: importFileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,
  },
});

export const uploadImportMiddleware = importUpload.single("file");


File: src/common/multer/save-file-to-disk.ts
--------------------------------------------------
Content of src/common/multer/save-file-to-disk.ts:
import path from "path";
import fs from "fs";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const saveFileToDisk = async (file: any) => {
  try {
    const fileBuffer = file.buffer;

    const uploadDir = "./uploads";
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
    const fileName = `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`;
    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }

    fs.writeFile(filePath, fileBuffer, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error saving file to disk:", err as any);
        throw new Error("Failed to save file.");
      }

      logger.info(`File saved to: ${filePath}`);
    });
    return { fileName, filePath };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error saving file:", error);
    throw new Error("Failed to save file.");
  }
};


File: src/common/multer/update-file-to-disk.ts
--------------------------------------------------
Content of src/common/multer/update-file-to-disk.ts:
import fs from "fs";
import path from "path";
import { logger } from "@/common/winston/winston";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const updateImageToDisk = async (fileName: string, file: any) => {
  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let response: any;
    const uploadDir = "./uploads";

    const newFilePath = path.join(uploadDir, fileName);
    const tempFilePath = path.join(uploadDir, `${fileName}_temp${path.extname(file.originalname)}`);

    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir);
    }

    fs.writeFile(tempFilePath, file.buffer, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error saving file to disk:", err as any);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        throw new Error(err as any);
      }

      response = fs.rename(tempFilePath, newFilePath, (renameErr) => {
        if (renameErr) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          logger.warn("Error replacing file:", renameErr as any);

          return false;
        }

        logger.info(`Image updated successfully: ${newFilePath}`);
        // Was removed from the response
        return { fileName, filePath: newFilePath };
      });
    });
    // Added return statement
    return response;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error updating image:", error);
    throw new Error(error);
  }
};


File: src/common/multer/delete-file-from-disk.ts
--------------------------------------------------
Content of src/common/multer/delete-file-from-disk.ts:
import fs from "fs";
import path from "path";
import { logger } from "@/common/winston/winston";

export const deleteFileFromDisk = (fileName: string) => {
  try {
    const uploadDir = "./uploads";
    const filePath = path.join(uploadDir, fileName);

    if (!fs.existsSync(filePath)) {
      throw new Error("File not found.");
    }

    fs.unlink(filePath, (err) => {
      if (err) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        logger.warn("Error deleting file:", err as any);
        throw new Error("Failed to delete the file.");
      }

      logger.info(`File deleted successfully: ${filePath}`);
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    logger.warn("Error deleting file:", error);
    throw new Error("Failed to delete the file.");
  }
};


File: src/common/mail-sender/mail-sender.ts
--------------------------------------------------
Content of src/common/mail-sender/mail-sender.ts:
import formData from "form-data";
import Mailgun from "mailgun.js";

const mailgun = new Mailgun(formData);

const options = {
  auth: {
    api_key: process.env.MAILGUN_API_KEY as string,
    domain: process.env.MAILGUN_DOMAIN as string,
  },
};

const mg = mailgun.client({ username: "api", key: options.auth.api_key }).messages;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const sendMail = async (mail: any) => {
  try {
    return await mg.create(options.auth.domain, mail);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    throw new Error(error);
  }
};


File: src/common/winston/winston.ts
--------------------------------------------------
Content of src/common/winston/winston.ts:
import "winston-daily-rotate-file";
import { createLogger, format, transports, Logger } from "winston";
import { StatusCodes } from "http-status-codes";
import { env } from "@/config/env";
import fs from "fs";
import colors from "colors/safe";
import "winston-mongodb";

const isWinstonEnabled = env.ENABLE_WINSTON === "1";
const isLogsEnabled = env.ENABLE_LOGS === "1";
const logsDirectory = env.LOGS_DIRECTORY;
const logsType = env.LOGS_TYPE;
const timeZone = env.TZ;
const logsFileDuration = env.LOG_FILE_DURATION;
const mongodbURI = env.MONGODB_URI;

if (!fs.existsSync(logsDirectory) && isWinstonEnabled && logsType !== "mongodb") {
  fs.mkdirSync(logsDirectory);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const formatConsoleMetaData = (metadata: any) => {
  if (!metadata) {
    return "";
  }

  // Extract common properties
  const { code, message, meta, name, response, details, status } = metadata;

  // Use details as a fallback for missing properties in metadata
  const resolvedDetails = details || {};

  return {
    details: {
      code: code || resolvedDetails.code || null,
      message: message || resolvedDetails.message || null,
      meta: { ...(meta || resolvedDetails.meta || {}) },
      data: {
        ...(response?.data || resolvedDetails?.data || {}),
      },
      status: response?.status || resolvedDetails?.status || status || null,
      statusText: response?.statusText || resolvedDetails?.statusText || null,
      name: name || resolvedDetails.name || null,
    },
  };
};

// NestJS-like console log format
const consoleFormat = format.combine(
  format.colorize({ all: true }),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  format.printf(({ level, message, timestamp, ...meta }: any) => {
    const metadata = meta && Object.keys(meta).length ? JSON.stringify(meta, null, 2) : "";
    return `[${colors.cyan(timestamp)} ${timeZone}] ${level}: ${meta.loggedUser ?? ""} ${message} ${metadata}`;
  }),
);

const fileFormat = format.combine(
  format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  format.json(),
);

const createMongoTransport = () =>
  new transports.MongoDB({
    db: mongodbURI,
    dbName: env.NODE_ENV,
    collection: env.MONGODB_ERROR_COLLECTION_NAME,
    level: "error",
    format: format.combine(
      format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
      format.errors({ stack: true }),
      format.json(),
    ),
  });

const createDailyRotateTransport = (level: string) =>
  new transports.DailyRotateFile({
    filename: `${level}-%DATE%.log`,
    dirname: logsDirectory,
    datePattern: "YYYY-MM-DD",
    level,
    zippedArchive: true,
    maxSize: "20m",
    maxFiles: logsFileDuration,
    format: format.combine(
      // eslint-disable-next-line no-extra-parens
      format((info) => (info.level === level ? info : false))(), // eslint-disable multiline-ternary
      fileFormat,
    ),
  });

const logLevels = {
  levels: {
    error: 0,
    warn: 1,
    http: 2,
    info: 3,
    debug: 4,
  },
  colors: {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "blue",
    debug: "magenta",
  },
};

const transportsList = [];
if (isWinstonEnabled) {
  transportsList.push(new transports.Console({ level: "info", format: consoleFormat }));
  if (logsType === "mongodb") {
    transportsList.push(createMongoTransport());
  } else {
    transportsList.push(createDailyRotateTransport("info"));
    transportsList.push(createDailyRotateTransport("error"));
  }
}

export const winstonLogger: Logger = createLogger({
  levels: logLevels.levels,
  format: format.combine(
    format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
    format.errors({ stack: true }),
    format.splat(),
    format.align(),
  ),
  transports: transportsList,
});

// Export logger functions with fallback to console logs if disabled
export const logger = isWinstonEnabled
  ? {
      // eslint-disable-next-line no-confusing-arrow
      info: (message: string, metadata?: Record<string, unknown>) =>
        isLogsEnabled ? winstonLogger.info(message, metadata) : null, // eslint-disable-line multiline-ternary
      // eslint-disable-next-line no-confusing-arrow
      debug: (message: string, metadata?: Record<string, unknown>) =>
        isLogsEnabled ? winstonLogger.debug(message, metadata) : null, // eslint-disable-line multiline-ternary

      warn: (message: string, metadata?: Record<string, unknown>) =>
        winstonLogger.warn(message, metadata),
      // eslint-disable-next-line no-confusing-arrow
      http: (message: string, metadata?: Record<string, unknown>) =>
        isLogsEnabled ? winstonLogger.http(message, metadata) : null, // eslint-disable-line multiline-ternary

      error: (message: string, metadata?: Record<string, unknown>) =>
        winstonLogger.error(message, metadata),
    }
  : {
      // eslint-disable-next-line no-confusing-arrow
      info: (message: string, metadata?: Record<string, unknown>) =>
        isLogsEnabled ? console.log(colors.green(message), metadata ?? "") : null, // eslint-disable-line multiline-ternary
      // eslint-disable-next-line no-confusing-arrow
      debug: (message: string, metadata?: Record<string, unknown>) =>
        isLogsEnabled ? console.log(colors.magenta(message), metadata ?? "") : null, // eslint-disable-line multiline-ternary

      warn: (message: string, metadata?: Record<string, unknown>) =>
        console.log(colors.yellow(message), metadata ?? ""),
      // eslint-disable-next-line no-confusing-arrow
      http: (message: string, metadata?: Record<string, unknown>) =>
        isLogsEnabled ? console.log(colors.blue(message), metadata ?? "") : null, // eslint-disable-line multiline-ternary

      error: (message: string, metadata?: Record<string, unknown>) =>
        console.log(colors.red(message), formatConsoleMetaData(metadata) ?? ""),
    };

export const morganStream = {
  write: (message: string) => {
    const statusCode = parseInt(message.split(" ")[2], 10);
    if (statusCode >= StatusCodes.BAD_REQUEST) {
      logger.warn(message.trim());
    } else {
      logger.http(message.trim());
    }
  },
};


File: src/routes/routes.ts
--------------------------------------------------
Content of src/routes/routes.ts:
import { Router } from "express";
import authRouter from "@/entities/auth/auth.route";
import usersRouter from "@/entities/users/users.route";
import filesRouter from "@/entities/files/files.route";
import healthRouter from "@/entities/health/health.route";

export const apiRoutes = Router();

apiRoutes.use("/health", healthRouter);
apiRoutes.use("/auth", authRouter);
apiRoutes.use("/users", usersRouter);
apiRoutes.use("/files", filesRouter);


File: src/entities/auth/auth.controller.ts
--------------------------------------------------
Content of src/entities/auth/auth.controller.ts:
import { NextFunction, Response } from "express";
import { AuthDto, RegisterDto, ResetPasswordDto } from "@/entities/auth/auth.dto";
import { AuthService } from "@/entities/auth/auth.services";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";

export class AuthController {
  private logFileName: string;
  private authService: AuthService;

  constructor() {
    this.logFileName = "[Auth Controller]";
    this.authService = new AuthService("[Auth Service]");
  }

  /**
   * Handles user login by verifying credentials and returning a token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  login = async (req: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    const loginDto: AuthDto = req.body;
    const { loggedUser } = req;
    logger.info(`${this.logFileName} login API invoked`, { email: loginDto.email, loggedUser });

    try {
      const result = await this.authService.login(loginDto);
      logger.info(`${this.logFileName} User login successful`, {
        email: loginDto.email,
        loggedUser,
      });
      res.json(result);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} login API error`, {
          email: loginDto.email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`${this.logFileName} login API error: Unknown error occurred`, { loggedUser });
      }
      next(error);
    }
  };

  /**
   * Handles user registration by creating a new user and returning the registered user details.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  register = async (req: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    const registerDto: RegisterDto = req.body;
    const { loggedUser } = req;
    logger.info(`${this.logFileName} Register API invoked`, {
      email: registerDto.email,
      loggedUser,
    });

    try {
      const result = await this.authService.register(registerDto);
      logger.info(`${this.logFileName} User registration successful`, {
        email: registerDto.email,
        loggedUser,
      });
      res.json(result);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Register API error`, {
          email: registerDto.email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`${this.logFileName} Register API error: Unknown error occurred`, {
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Handles user logout by invalidating the user's token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  logout = async (req: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    const token = req.headers.authorization?.split(" ")[1];
    const { loggedUser } = req;
    logger.info(`${this.logFileName} Logout API invoked`, { token, loggedUser });

    try {
      const result = await this.authService.logout(token!);
      logger.info(`${this.logFileName} User logout successful`, { token, loggedUser });
      res.json(result);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Logout API error`, {
          token,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`${this.logFileName} Logout API error: Unknown error occurred`, { loggedUser });
      }
      next(error);
    }
  };

  /**
   * Extends the user's token and returns a new token.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  extendToken = async (req: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    const token = req.headers.authorization?.split(" ")[1];
    const { loggedUser } = req;
    logger.info(`${this.logFileName} ExtendToken API invoked`, { token, loggedUser });

    try {
      const newToken = await this.authService.extendToken(token!);
      logger.info(`${this.logFileName} Token extended successfully`, { newToken, loggedUser });
      res.json({ token: newToken });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} ExtendToken API error`, {
          token,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`${this.logFileName} ExtendToken API error: Unknown error occurred`, {
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Initiates the forgot password process for a user.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  forgotPassword = async (req: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    const { email } = req.body;
    const { loggedUser } = req;
    logger.info(`${this.logFileName} Forgot password API invoked`, { email, loggedUser });

    try {
      const message = await this.authService.forgotPassword(email);
      logger.info(`${this.logFileName} Forgot password successful`, {
        email,
        loggedUser,
      });
      res.json(message);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Forgot password API error`, {
          email,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`${this.logFileName} Forgot password API error: Unknown error occurred`, {
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Initiates the reset password process for a user.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  resetPassword = async (req: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    const { resetToken, password, confirmPassword } = req.body;
    const { loggedUser } = req;
    logger.info(`${this.logFileName} Reset password API invoked`, { resetToken, loggedUser });

    const resetPasswordDto: ResetPasswordDto = {
      password: password as string,
      confirmPassword: confirmPassword as string,
      resetToken: resetToken as string,
    };
    try {
      const message = await this.authService.resetPassword(resetPasswordDto);
      logger.info(`${this.logFileName} Reset password successful`, {
        resetToken,
        loggedUser,
      });
      res.json(message);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Reset password API error`, {
          resetToken,
          error: error.message,
          loggedUser,
        });
      } else {
        logger.warn(`${this.logFileName} Reset password API error: Unknown error occurred`, {
          loggedUser,
        });
      }
      next(error);
    }
  };
}


File: src/entities/auth/auth.dto.ts
--------------------------------------------------
Content of src/entities/auth/auth.dto.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { z } from "zod";

extendZodWithOpenApi(z);

const PASSWORD_SCHEMA = z
  .string()
  .min(8)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  .superRefine((value: string, context: any) => {
    if (value === value.toLowerCase()) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a capital letter",
      });
    }

    if (value === value.toUpperCase()) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a lowercase letter",
      });
    }

    if (!/\d/.test(value)) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a number",
      });
    }

    // eslint-disable-next-line no-useless-escape
    if (!/[!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~\-]/.test(value)) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Missing a special character",
      });
    }
  });

export const AuthSchema = z.object({
  email: z.string().email(),
  password: PASSWORD_SCHEMA,
});

export const LogoutSchema = z.object({
  success: z.boolean(),
});

export const ExtendTokenSchema = z.object({
  token: z.string(),
});

export const ForgotPasswordSchema = z.object({
  email: z.string().email().trim(),
});

export const ResetPasswordSchema = z
  .object({
    resetToken: z.string(),
    password: PASSWORD_SCHEMA,
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export const RegisterSchema = z
  .object({
    name: z.string().min(4, { message: "Name must be at least 4 characters long" }),
    username: z.string().min(4, { message: "Username must be at least 4 characters long" }),
    email: z.string().email(),
    password: PASSWORD_SCHEMA,
    confirmPassword: z.string().min(8),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export type RegisterDto = z.infer<typeof RegisterSchema>;
export type AuthDto = z.infer<typeof AuthSchema>;
export type ResetPasswordDto = z.infer<typeof ResetPasswordSchema>;


File: src/entities/auth/auth.route.ts
--------------------------------------------------
Content of src/entities/auth/auth.route.ts:
import { Router } from "express";
import { authMiddleware, zodValidation } from "@/middlewares";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import {
  AuthSchema,
  ExtendTokenSchema,
  ForgotPasswordSchema,
  LogoutSchema,
  RegisterSchema,
  ResetPasswordSchema,
} from "@/entities/auth/auth.dto";
import { AuthController } from "@/entities/auth/auth.controller";

const authRouter = Router();

const TAG = "Auth";
const ROUTE = `/${TAG.toLowerCase()}`;

export const authRegistry = new OpenAPIRegistry();
const authController = new AuthController();

authRegistry.register(TAG, AuthSchema);

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/login`,
  tags: [TAG],
  summary: "Login",
  request: {
    body: {
      content: { "application/json": { schema: AuthSchema } },
    },
  },
  responses: createApiResponse(AuthSchema, "Login Successfully"),
});
authRouter.post("/login", zodValidation(AuthSchema), authController.login);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/register`,
  tags: [TAG],
  summary: "Register",
  request: {
    body: {
      content: { "application/json": { schema: RegisterSchema } },
    },
  },
  responses: createApiResponse(RegisterSchema, "Register Successfully"),
});
authRouter.post("/register", zodValidation(RegisterSchema), authController.register);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/extend-token`,
  tags: [TAG],
  summary: "Extend Token",
  request: {
    body: {
      content: { "application/json": { schema: ExtendTokenSchema } },
    },
  },
  responses: createApiResponse(ExtendTokenSchema, "Token Extended Successfully"),
});
authRouter.post(
  "/extend-token",
  authMiddleware,
  zodValidation(ExtendTokenSchema),
  authController.extendToken,
);

//====================================================================================================

authRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/logout`,
  tags: [TAG],
  summary: "Logout",
  responses: createApiResponse(LogoutSchema, "Logout Successfully"),
});
authRouter.get("/logout", authMiddleware, authController.logout);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/forgot-password`,
  tags: [TAG],
  summary: "Forgot Password",
  request: {
    body: {
      content: { "application/json": { schema: ForgotPasswordSchema } },
    },
  },
  responses: createApiResponse(ForgotPasswordSchema, "Reset link sent. Check you email"),
});
authRouter.post(
  "/forgot-password",
  zodValidation(ForgotPasswordSchema),
  authController.forgotPassword,
);

//====================================================================================================

authRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/reset-password`,
  tags: [TAG],
  summary: "Reset Password",
  request: {
    body: {
      content: { "application/json": { schema: ResetPasswordSchema } },
    },
  },
  responses: createApiResponse(ResetPasswordSchema, "Password reset successful"),
});
authRouter.post(
  "/reset-password",
  zodValidation(ResetPasswordSchema),
  authController.resetPassword,
);

export default authRouter;


File: src/entities/auth/auth.services.ts
--------------------------------------------------
Content of src/entities/auth/auth.services.ts:
import { compare, hash } from "bcrypt";
import { logger } from "@/common/winston/winston";
import { AuthDto, RegisterDto, ResetPasswordDto } from "@/entities/auth/auth.dto";
import { generateToken, verifyToken } from "@/common/jwt/jwt";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { UsersService } from "@/entities/users/users.service";
import { sendMail } from "@/common/mail-sender/mail-sender";
import { GenericRepository } from "@/common/repository/repository";
import { CreateUsersDto, UpdateUsersDto, UsersDto, UsersModel } from "../users/users.dto";
import { env } from "@/config/env";
import { createTemplate } from "@/template/create-template";

export class AuthService {
  private collectionName: string;
  private logFileName: string;
  private usersService: UsersService;
  private usersRepository: GenericRepository<UsersDto, UpdateUsersDto, CreateUsersDto>;

  constructor(logFileName: string) {
    this.collectionName = "user";
    this.logFileName = logFileName;
    this.usersService = new UsersService(this.collectionName, `[${this.collectionName} Service]`);
    this.usersRepository = new GenericRepository(UsersModel, `[${this.collectionName} Repository]`);
  }

  /**
   * Handles user login by verifying the credentials and generating a token.
   * @param authData - Object containing user login credentials.
   * @returns Object containing the generated token.
   * @throws HTTP error if user not found or password is invalid.
   */
  login = async (authData: AuthDto) => {
    logger.info(`${this.logFileName} login service invoked`, { email: authData.email });

    try {
      const user = await this.usersService.getByEmail(authData.email);

      if (!user) {
        logger.warn(`${this.logFileName} ${this.collectionName} not found during login`, {
          email: authData.email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      if (!(await compare(authData.password, user.password as string))) {
        logger.warn(`${this.logFileName} Invalid password during login`, {
          email: authData.email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid email or password", {
          resource: "Auth",
        });
      }

      const token = generateToken({
        id: user.uuid,
        username: user.username,
        name: user.name,
        email: user.email,
      });

      logger.info(`${this.logFileName} Token received successfully`, { email: authData.email });
      return { user, token };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error during login`, {
          error: error.message,
          email: authData.email,
        });
        throw new Error(`Error while login: ${error.message}`);
      }
      logger.warn(`${this.logFileName} Unknown error during login`, { email: authData.email });
      throw new Error("Unknown error occurred while login");
    }
  };

  /**
   * Registers a new user and generates a token for the user.
   * @param registerDto - Registration data for a new user.
   * @returns Object containing the registered user and generated token.
   * @throws HTTP error if user already exists.
   */
  register = async (registerDto: RegisterDto) => {
    logger.info(`${this.logFileName} Register service invoked`, { email: registerDto.email });

    try {
      const user = await this.usersService.getByEmail(registerDto.email);

      if (user) {
        logger.warn(
          `${this.logFileName} ${this.collectionName} already exists during registration`,
          {
            email: registerDto.email,
          },
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} already exist!`, {
          resource: "Auth",
        });
      }

      await this.usersService.create(registerDto);

      const login = await this.login(registerDto);

      logger.info(`${this.logFileName} ${this.collectionName} registered successfully`, {
        email: registerDto.email,
      });
      return login;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error during registration`, {
          error: error.message,
          email: registerDto.email,
        });
        throw new Error(`${this.logFileName} Error while login: ${error.message}`);
      }
      logger.warn(`${this.logFileName} Unknown error during registration`, {
        email: registerDto.email,
      });
      throw new Error(`${this.logFileName} Unknown error occurred while login`);
    }
  };

  /**
   * Extends the user's token and returns a new token.
   * @param token - The current token to extend.
   * @returns The newly extended token.
   * @throws Error if token extension fails.
   */
  extendToken = async (token: string) => {
    logger.info(`${this.logFileName} Extend token service invoked`, { token });

    try {
      const payload = verifyToken(token);
      const newToken = generateToken({
        id: payload.id,
        username: payload.username,
        name: payload.name,
        email: payload.email,
      });
      logger.info(`${this.logFileName} Token extended successfully`, { newToken });
      return newToken;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error extending token`, { error: error.message, token });
        throw new Error(`${this.logFileName} Error extend token: ${error.message}`);
      }
      logger.warn(`${this.logFileName} Unknown error while extending token`, { token });
      throw new Error(`${this.logFileName} Unknown error occurred while extend token`);
    }
  };

  /**
   * Logs out the user by invalidating the token.
   * @param token - The token to invalidate.
   * @returns Object with the invalidated token and success status.
   * @throws Error if logout fails.
   */
  logout = async (token: string) => {
    logger.info(`${this.logFileName} Logout service invoked`, { token });

    try {
      return { token, success: true };
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error during logout`, { error: error.message, token });
        throw new Error(`Error logout: ${error.message}`);
      }
      logger.warn(`${this.logFileName} Unknown error during logout`, { token });
      throw new Error("Unknown error occurred while logout");
    }
  };

  /**
   * Initiates the forgot password process for a user.
   * @param email User's email address
   * @returns message that email sent.
   * @throws HTTP error if any error occur.
   */
  forgotPassword = async (email: string) => {
    logger.info(`${this.logFileName} Forgot password service invoked`, { email });

    try {
      const user = await this.usersService.getByEmail(email);

      if (!user) {
        logger.warn(`${this.logFileName} ${this.collectionName} does not exists!`, {
          email,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      const resetToken = generateToken({
        id: user.uuid,
        username: user.username,
        name: user.name,
        email: user.email,
      });

      await this.usersService.update(user.uuid, { resetToken });

      // Send email
      try {
        const context = {
          accountName: user.name,
          URL: `${env.APP_URL}/reset-password?token=${resetToken}`,
        };

        const options = {
          from: `${env.MAILGUN_NAME} <${env.MAILGUN_SENDER_EMAIL}>`,
          to: email,
          subject: "Reset Password Requested",
          html: createTemplate("forgot-password", context),
        };

        await sendMail(options);
      } catch (error) {
        console.log(`Error: ${error}`);
        throw new Error(`Error while sending email: ${error}`);
      }

      logger.info(`${this.logFileName} Email reset link successfully sent`, { email, resetToken });
      return { message: "Reset link sent. Check your inbox" };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error during registration`, {
          error: error.message,
          email,
        });
        throw new Error(`${this.logFileName} Error while forgot password: ${error.message}`);
      }
      logger.warn(`${this.logFileName} Unknown error during registration`, {
        email,
      });
      throw new Error(`${this.logFileName} Unknown error occurred while forgot password`);
    }
  };

  resetPassword = async (resetPasswordDto: ResetPasswordDto) => {
    logger.info(`${this.logFileName} reset password service invoked`, {
      resetToken: resetPasswordDto.resetToken,
    });

    try {
      const user = await this.usersRepository.getByField("resetToken", resetPasswordDto.resetToken);

      if (!user) {
        logger.warn(`${this.logFileName} ${this.collectionName} does not exists!`, {
          resetToken: resetPasswordDto.resetToken,
        });
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: "Auth",
        });
      }

      if (!user.resetToken || resetPasswordDto.resetToken !== user.resetToken) {
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid or expired reset token.");
      }

      const hashedPassword = await hash(resetPasswordDto.password, env.HASH!);

      await this.usersRepository.update(user.uuid, {
        password: hashedPassword,
        resetToken: undefined,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } as any);

      logger.info(`${this.logFileName} Password reset successful`, {
        resetToken: resetPasswordDto.resetToken,
      });
      return { message: "Password reset successful" };
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error during registration`, {
          error: error.message,
          resetToken: resetPasswordDto.resetToken,
        });
        throw new Error(`${this.logFileName} Error while reset password: ${error.message}`);
      }
      logger.warn(`${this.logFileName} Unknown error during registration`, {
        resetToken: resetPasswordDto.resetToken,
      });
      throw new Error(`${this.logFileName} Unknown error occurred while reset password`);
    }
  };
}


File: src/entities/health/health.controller.ts
--------------------------------------------------
Content of src/entities/health/health.controller.ts:
import { NextFunction, Response } from "express";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import {
  checkMongoDB,
  checkRedis,
  createHealthCheckResponse,
  formatMemoryUsage,
} from "@/entities/health/health.helper";
import { StatusCodes } from "http-status-codes";
import redis from "@/config/redis/redis";
import fs from "fs";
import { env } from "@/config/env";
import path from "path";

export class HealthController {
  private logFileName: string;

  constructor() {
    this.logFileName = "[Auth Controller]";
  }

  /**
   * Handles health of server.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  health = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      const healthCheck = {
        mongo: await checkMongoDB(),
        redis: await checkRedis(),
        server: {
          status: "healthy",
          uptime: process.uptime(),
          memoryUsage: formatMemoryUsage(),
        },
      };

      const overallStatus = Object.values(healthCheck)
        .map((service) => service.status)
        .includes("unhealthy")
        ? "unhealthy"
        : "healthy";

      res
        .status(overallStatus === "healthy" ? StatusCodes.OK : StatusCodes.INTERNAL_SERVER_ERROR)
        .json(createHealthCheckResponse(overallStatus, healthCheck));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} health API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} health API error: Unknown error occurred`);
      }
      next(error);
    }
  };

  /**
   * * Clear Redis API cache.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  clearCache = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      const stream = redis.scanStream({
        match: "apiResponseCache*", // Pattern to match keys
        count: 100, // Process 100 keys per iteration
      });

      const keysToDelete: string[] = [];

      for await (const keys of stream) {
        keysToDelete.push(...keys);
      }

      if (keysToDelete.length > 0) {
        await redis.del(...keysToDelete);
        logger.info(`Cleared ${keysToDelete.length} keys with prefix apiResponseCache`);
      } else {
        logger.info("No keys found with prefix apiResponseCache");
      }
      res.json({ message: "Cache cleared successfully" });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} clearCache API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} clearCache API error: Unknown error occurred`);
      }
      next(error);
    }
  };

  /**
   * Handles health of server.
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   */
  clearLogFiles = async (_: CustomRequest, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!fs.existsSync(env.LOGS_DIRECTORY)) {
        fs.mkdirSync(env.LOGS_DIRECTORY);
      }

      const files = fs.readdirSync(env.LOGS_DIRECTORY);

      files.forEach((file) => {
        const filePath = path.join(env.LOGS_DIRECTORY, file);
        fs.unlinkSync(filePath);
      });

      res.json({ message: "All log files have been cleared." });
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} clearLogFiles API error`, {
          error: error.message,
        });
      } else {
        logger.warn(`${this.logFileName} clearLogFiles API error: Unknown error occurred`);
      }
      next(error);
    }
  };
}


File: src/entities/health/health.helper.ts
--------------------------------------------------
Content of src/entities/health/health.helper.ts:
import mongoose from "mongoose";
import redis from "@/config/redis/redis";

export const checkRedis = async () => {
  try {
    await redis.ping();
    return { status: "healthy", details: {} };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    return { status: "unhealthy", details: { error: error.message } };
  }
};

export const checkMongoDB = async () => {
  try {
    const isConnected = mongoose.connection.readyState === 1;
    return {
      status: isConnected ? "healthy" : "unhealthy",
      details: {},
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    return { status: "unhealthy", details: { error: error.message } };
  }
};

export const formatMemoryUsage = () => {
  const memoryUsage = process.memoryUsage();
  return {
    rss: `${(memoryUsage.rss / 1024 / 1024).toFixed(2)} MB`,
    heapTotal: `${(memoryUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`,
    heapUsed: `${(memoryUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`,
    external: `${(memoryUsage.external / 1024 / 1024).toFixed(2)} MB`,
  };
};

export const createHealthCheckResponse = (status: string, details: Record<string, unknown>) => ({
  status,
  details,
});


File: src/entities/health/health.route.ts
--------------------------------------------------
Content of src/entities/health/health.route.ts:
import { Router } from "express";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { HealthController } from "@/entities/health/health.controller";
import { z } from "zod";

const healthRouter = Router();

const TAG = "Health";
const ROUTE = `/${TAG.toLowerCase()}`;

export const healthRegistry = new OpenAPIRegistry();
const healthController = new HealthController();

healthRegistry.register(TAG, z.any());

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: "Get health check",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/", healthController.health);

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/clear-cache`,
  summary: "Clear cache",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/clear-cache", healthController.clearCache);

//====================================================================================================

healthRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/clear-logs`,
  summary: "Clear log files",
  tags: [TAG],
  security: [],
  responses: createApiResponse(z.any(), "Success"),
});

healthRouter.get("/clear-logs", healthController.clearLogFiles);

export default healthRouter;


File: src/entities/users/users.dto.ts
--------------------------------------------------
Content of src/entities/users/users.dto.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { model } from "mongoose";
import { z } from "zod";
import { zodSchema } from "@zodyac/zod-mongoose";

extendZodWithOpenApi(z);

export const UsersSchema = z.object({
  uuid: z.string(),
  name: z.string().min(4, "Name must be at least 4 characters long"),
  username: z.string().min(4, "Username must be at least 4 characters long"),
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
  bio: z.string().optional(),
  phoneNumber: z.string().optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
  resetToken: z.string().optional(),
});

export const CreateUsersSchema = UsersSchema.omit({
  uuid: true,
  createdAt: true,
  updatedAt: true,
});

export const UpdateUsersSchema = z.object({
  name: z.string().min(4, "Name must be at least 4 characters long").optional(),
  username: z.string().min(4, "Username must be at least 4 characters long").optional(),
  email: z.string().email("Invalid email address").optional(),
  bio: z.string().optional(),
  phoneNumber: z.string().optional(),
  updatedAt: z.date().optional(),
  resetToken: z.string().optional(),
});

export type UsersDto = z.infer<typeof UsersSchema>;
export type CreateUsersDto = z.infer<typeof CreateUsersSchema>;
export type UpdateUsersDto = z.infer<typeof UpdateUsersSchema>;

const schema = zodSchema(UsersSchema);
export const UsersModel = model("Users", schema);


File: src/entities/users/users.service.ts
--------------------------------------------------
Content of src/entities/users/users.service.ts:
import { UsersModel, UsersDto, UpdateUsersDto, CreateUsersDto } from "@/entities/users/users.dto";
import { env } from "@/config/env";
import { hash } from "bcrypt";
import { v4 as uuidv4 } from "uuid";
import { FindByQueryDto } from "@/schemas/find-by-query";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { parseAsync } from "json2csv";
import { GenericRepository } from "@/common/repository/repository";

export class UsersService {
  private usersRepository: GenericRepository<UsersDto, UpdateUsersDto, CreateUsersDto>;
  private collectionName: string;
  private logFileName: string;

  constructor(collectionName: string, logFileName: string) {
    this.usersRepository = new GenericRepository(UsersModel, `[${collectionName} Repository]`);
    this.collectionName = collectionName;
    this.logFileName = logFileName;
  }

  /**
   * Fetches all entities from the database.
   * @returns Array of entities
   */
  getAll = async (): Promise<UsersDto[]> => {
    try {
      logger.info(`${this.logFileName} Fetching all ${this.collectionName}`);
      const data = await this.usersRepository.getAll();
      return data;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while fetching all ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName}`);
    }
  };

  /**
   * Fetches a entity by their id.
   * @param id - entity's unique identifier
   * @returns entity data
   */
  getById = async (id: string): Promise<UsersDto> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.collectionName} with id: ${id}`);
      const data = await this.usersRepository.getById(id);

      if (!data) {
        logger.warn(`${this.logFileName} ${this.collectionName} with id ${id} not found`);
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} not found`, {
          resource: this.collectionName,
        });
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching ${this.collectionName} by id`, {
          id,
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName} by id: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while fetching ${this.collectionName} by id`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by id`);
    }
  };

  /**
   * Fetches a entity by their UUID.
   * @param uuid - entity's unique identifier
   * @returns entity data
   */
  getByUuid = async (uuid: string): Promise<UsersDto> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.collectionName} with uuid: ${uuid}`);
      const data = await this.usersRepository.getByUuid(uuid);

      if (!data) {
        logger.warn(`${this.logFileName} ${this.collectionName} with uuid ${uuid} not found`);
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} not found`, {
          resource: this.collectionName,
        });
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching ${this.collectionName} by uuid`, {
          uuid,
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName} by uuid: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while fetching ${this.collectionName} by uuid`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by uuid`);
    }
  };

  /**
   * Fetches a entity by their email.
   * @param email - entity's email
   * @returns entity data or false if not found
   */
  getByEmail = async (email: string): Promise<UsersDto | false> => {
    try {
      logger.info(`${this.logFileName} Fetching ${this.collectionName} with email: ${email}`);
      const data = await this.usersRepository.getByEmail(email);

      if (!data) {
        logger.warn(`${this.logFileName} ${this.collectionName} with email ${email} not found`);
        return false;
      }

      return data;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching ${this.collectionName} by email`, {
          email,
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName} by email: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while fetching ${this.collectionName} by email`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName} by email`);
    }
  };

  /**
   * Finds entities based on query parameters.
   * @param options - Query parameters like pagination, sorting, and filtering
   * @returns Paginated entity data
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  findByQuery = async (options: FindByQueryDto): Promise<any> => {
    try {
      logger.info(
        `${this.logFileName} Querying ${this.collectionName} with options: ${JSON.stringify(options)}`,
      );
      return await this.usersRepository.findByQuery(options);
    } catch (error) {
      logger.warn(`${this.logFileName} Error querying ${this.collectionName}`, {
        options,
        error: error instanceof Error ? error.message : "Unknown error",
      });
      throw new Error(`Error querying ${this.collectionName}`);
    }
  };

  /**
   * Creates a new entity.
   * @param createDto - Data for creating a new entity
   * @returns Created entity data
   */
  create = async (createDto: CreateUsersDto): Promise<UsersDto> => {
    try {
      logger.info(
        `${this.logFileName} Creating ${this.collectionName} with email: ${createDto.email}`,
      );
      const data = await this.usersRepository.getByEmail(createDto.email);
      const username = await this.usersRepository.getByUsername(createDto.username);

      if (data) {
        logger.warn(
          `${this.logFileName} ${this.collectionName} with email ${createDto.email} already exists`,
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} already exists!`, {
          resource: this.collectionName,
        });
      }

      if (username) {
        logger.warn(
          `${this.logFileName} ${this.collectionName} with username ${createDto.username} already exists.`,
        );
        throw createHttpError(StatusCodes.BAD_REQUEST, "username is taken!", {
          resource: "Users",
        });
      }

      const hashedPassword = await hash(createDto.password, env.HASH!);
      const currentTime = new Date();
      const newDto = {
        ...createDto,
        uuid: uuidv4(),
        password: hashedPassword,
        createdAt: currentTime,
        updatedAt: currentTime,
      };

      return await this.usersRepository.create(newDto);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error creating ${this.collectionName}`, {
          createDto,
          error: error.message,
        });
        throw new Error(`Error creating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while creating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionName}`);
    }
  };

  /**
   * Updates an existing entity.
   * @param uuid - entity's unique identifier
   * @param updateDto - Data to update the entity with
   * @returns Updated entity data
   */
  update = async (uuid: string, updateDto: UpdateUsersDto): Promise<UsersDto | null> => {
    try {
      logger.info(`${this.logFileName} Updating ${this.collectionName} with uuid: ${uuid}`);
      const data = await this.getByUuid(uuid);

      if (!data) {
        logger.warn(`${this.logFileName} ${this.collectionName} with uuid ${uuid} does not exist!`);
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: this.collectionName,
        });
      }

      if (updateDto.email) {
        const email = await this.usersRepository.getByEmail(updateDto.email);
        if (email) {
          logger.warn(
            `${this.logFileName} ${this.collectionName} with email ${updateDto.email} already exists`,
          );
          throw createHttpError(StatusCodes.BAD_REQUEST, "Email already exists!", {
            resource: this.collectionName,
          });
        }
      }

      if (updateDto.username) {
        const username = await this.usersRepository.getByUsername(updateDto.username);
        if (username) {
          logger.warn(
            `${this.logFileName} ${this.collectionName} with username ${updateDto.email} already exists`,
          );
          throw createHttpError(StatusCodes.BAD_REQUEST, "Username already exists!", {
            resource: this.collectionName,
          });
        }
      }

      // If (updateDto.password) {
      //   UpdateDto.password = await hash(updateDto.password, env.HASH!);
      // }

      updateDto.updatedAt = new Date();

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return await this.usersRepository.update(uuid, updateDto as any);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error updating ${this.collectionName}`, {
          uuid,
          updateDto,
          error: error.message,
        });
        throw new Error(`Error updating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while updating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while updating ${this.collectionName}`);
    }
  };

  /**
   * Deletes a entity.
   * @param uuid - entity's unique identifier
   * @returns Deletion result
   */
  delete = async (uuid: string): Promise<UsersDto | null> => {
    try {
      logger.info(`${this.logFileName} Deleting ${this.collectionName} with uuid: ${uuid}`);
      const data = await this.getByUuid(uuid);

      if (!data) {
        logger.warn(`${this.logFileName} ${this.collectionName} with uuid ${uuid} does not exist!`);
        throw createHttpError(StatusCodes.BAD_REQUEST, `${this.collectionName} does not exist!`, {
          resource: this.collectionName,
        });
      }

      return await this.usersRepository.delete(uuid);
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error deleting ${this.collectionName}`, {
          uuid,
          error: error.message,
        });
        throw new Error(`Error deleting ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while deleting ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while deleting ${this.collectionName}`);
    }
  };

  /**
   * Deletes multiple entities by their uuids.
   * @param uuids - List of entity uuids to delete
   * @returns Deletion result
   */
  deleteAll = async (uuids: string[]): Promise<{ deletedCount: number }> => {
    if (!Array.isArray(uuids) || uuids.length === 0) {
      logger.warn(`${this.logFileName} Invalid array of uuids for bulk delete`);
      throw new Error("Invalid array of uuids");
    }

    const result = await this.usersRepository.deleteAll(uuids);

    if (result.deletedCount === 0) {
      logger.warn(`${this.logFileName} No ${this.collectionName} found to delete`, { uuids });
      throw new Error(`No ${this.collectionName} found to delete`);
    }

    return result;
  };

  /**
   * Import entities.
   * @param importDto - Data for creating entities
   * @param accountId - account id for creating entities
   * @returns number of imported entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  import = async (importDto: CreateUsersDto[]): Promise<any> => {
    try {
      logger.info(`${this.logFileName} Starting import ${this.collectionName}`);

      const imported = await this.usersRepository.import(importDto);

      logger.info(
        `${this.logFileName} ${imported.createdCount} completed, ${imported.skippedCount} skipped for ${this.collectionName}`,
      );

      return imported;
    } catch (error) {
      if (createHttpError.isHttpError(error)) {
        throw error;
      }

      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error creating ${this.collectionName}`, {
          importDto,
          error: error.message,
        });
        throw new Error(`Error creating ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while creating ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while creating ${this.collectionName}`);
    }
  };

  /**
   * Export entities from the database.
   * @returns csv of entities
   */
  export = async (): Promise<string> => {
    try {
      logger.info(`${this.logFileName} Fetching all ${this.collectionName}`);
      const data = await this.usersRepository.getAll();

      if (data.length === 0) {
        throw createHttpError(StatusCodes.NOT_FOUND, `No ${this.collectionName} found to export`);
      }

      const csv = await parseAsync(data);

      return csv;
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
        throw new Error(`Error fetching ${this.collectionName}: ${error.message}`);
      }
      logger.warn(
        `${this.logFileName} Unknown error occurred while fetching all ${this.collectionName}`,
      );
      throw new Error(`Unknown error occurred while fetching ${this.collectionName}`);
    }
  };
}


File: src/entities/users/users.controller.ts
--------------------------------------------------
Content of src/entities/users/users.controller.ts:
import { NextFunction, Response } from "express";
import { UsersService } from "@/entities/users/users.service";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { csvBufferToJson, csvToJson } from "@/utils/csv-to-json";
import { createResponse } from "@/utils/create-response";

export class UsersController {
  public collectionName: string;
  public logFileName: string;
  public usersService: UsersService;

  constructor() {
    this.collectionName = "users";
    this.logFileName = `[${this.collectionName} Controller]`;
    this.usersService = new UsersService(this.collectionName, `[${this.collectionName} Service]`);
  }

  /**
   * Get all entities objects
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON list of entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getAll = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    try {
      logger.info(`${this.logFileName} Fetching all ${this.collectionName}`);
      const data = await this.usersService.getAll();

      return res.json(createResponse(req, data));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching all ${this.collectionName}`, {
          error: error.message,
        });
      }
      next(error);
    }
  };

  /**
   * Get entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getById = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { id } = req.params;
    const { loggedUser } = req;
    try {
      logger.info(`${this.logFileName} Fetching ${this.collectionName} by ID`, { loggedUser, id });
      const data = await this.usersService.getById(id);
      return res.json(createResponse(req, data));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching ${this.collectionName} by ID`, {
          error: error.message,
          loggedUser,
          id,
        });
      }
      next(error);
    }
  };

  /**
   * Get entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getByUuid = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { uuid } = req.params;
    const { loggedUser } = req;
    try {
      logger.info(`${this.logFileName} Fetching ${this.collectionName} by uuid`, {
        loggedUser,
        uuid,
      });
      const data = await this.usersService.getByUuid(uuid);
      return res.json(createResponse(req, data));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching ${this.collectionName} by uuid`, {
          error: error.message,
          loggedUser,
          uuid,
        });
      }
      next(error);
    }
  };

  /**
   * Get entity by email
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON entity object
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getByEmail = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { email } = req.params;
    const { loggedUser } = req;
    try {
      logger.info(`${this.logFileName} Fetching ${this.collectionName} by email`, {
        loggedUser,
        email,
      });
      const data = await this.usersService.getByEmail(email);
      return res.json(createResponse(req, data));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error fetching ${this.collectionName} by email`, {
          error: error.message,
          loggedUser,
          email,
        });
      }
      next(error);
    }
  };

  /**
   * Find entities by query (pagination, sorting, filtering)
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON result of the query
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  findByQuery = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    try {
      const { paginate, orderBy, filter } = req.body;
      const queryOptions = { paginate, orderBy, filter };
      logger.info(`${this.logFileName} Finding ${this.collectionName} by query`, { queryOptions });

      const result = await this.usersService.findByQuery(queryOptions);
      return res.json(createResponse(req, result));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error finding ${this.collectionName} by query`, {
          error: error.message,
        });
      }
      next(error);
    }
  };

  /**
   * Create a new entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  create = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const createDto = req.body;
    const { loggedUser } = req;
    try {
      logger.info(`${this.logFileName} Creating new ${this.collectionName}`, {
        loggedUser,
        createDto,
      });
      const created = await this.usersService.create(createDto);
      return res.json(
        createResponse(req, created, "User created successfully", StatusCodes.CREATED),
      );
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error creating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          createDto,
        });
      }
      next(error);
    }
  };

  /**
   * Update an existing entity
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON updated entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { uuid } = req.params;
    const updateDto = req.body;
    const { loggedUser } = req;
    try {
      logger.info(`${this.logFileName} Updating ${this.collectionName}`, {
        loggedUser,
        uuid,
        updateDto,
      });
      const updatedData = await this.usersService.update(uuid, updateDto);
      return res.json(createResponse(req, updatedData, "User updated successfully"));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error updating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          uuid,
          updateDto,
        });
      }
      next(error);
    }
  };

  /**
   * Delete a entity by ID
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  delete = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { uuid } = req.params;
    const { loggedUser } = req;
    try {
      logger.info(`${this.logFileName} Deleting ${this.collectionName} by uuid`, {
        loggedUser,
        uuid,
      });
      await this.usersService.delete(uuid);
      return res.json(createResponse(req, {}, "User deleted Successfully"));
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error deleting ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          uuid,
        });
      }
      next(error);
    }
  };

  /**
   * Delete multiple entities
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON success message
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  deleteAll = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { uuids } = req.body;
    const { loggedUser } = req;
    try {
      if (!Array.isArray(uuids) || uuids.length === 0) {
        throw createHttpError(StatusCodes.BAD_REQUEST, "Invalid or empty array of uuids", {
          resource: this.collectionName,
        });
      }

      logger.info(`${this.logFileName} Deleting multiple ${this.collectionName}`, {
        loggedUser,
        uuids,
      });
      const result = await this.usersService.deleteAll(uuids);

      return res.json(
        createResponse(
          req,
          {},
          `${result.deletedCount} ${this.collectionName} deleted successfully`,
        ),
      );
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error deleting ${this.collectionName}`, {
          error: error.message,
          loggedUser,
          uuids,
        });
      }
      next(error);
    }
  };

  /**
   * Import entities
   * @param req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON created entity
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  import = async (req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    const { loggedUser, file } = req;
    if (!file) {
      return next(createHttpError(StatusCodes.BAD_REQUEST, "No file uploaded."));
    }
    try {
      logger.info(`${this.logFileName} Importing new ${this.collectionName}`, { loggedUser });
      let importEntries;

      if (file.buffer) {
        importEntries = await csvBufferToJson(file.buffer);
      } else {
        importEntries = await csvToJson(file.path);
      }

      const imported = await this.usersService.import(importEntries);

      return res.json(
        createResponse(
          req,
          imported.createdEntities,
          `${imported.createdCount} completed, ${imported.skippedCount} skipped`,
        ),
      );
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error creating ${this.collectionName}`, {
          error: error.message,
          loggedUser,
        });
      }
      next(error);
    }
  };

  /**
   * Export entities
   * @param _req - CustomRequest object
   * @param res - Response object
   * @param next - Next middleware function
   * @returns JSON list of entities
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  export = async (_req: CustomRequest, res: Response, next: NextFunction): Promise<any> => {
    try {
      logger.info(`${this.logFileName} Exporting ${this.collectionName}`);
      const csv = await this.usersService.export();
      res.header("Content-Type", "text/csv");
      res.header("Content-Disposition", "attachment; filename=accounts.csv");
      res.send(csv);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn(`${this.logFileName} Error exporting ${this.collectionName}`, {
          error: error.message,
        });
      }
      next(error);
    }
  };
}


File: src/entities/users/users.route.ts
--------------------------------------------------
Content of src/entities/users/users.route.ts:
import { UpdateUsersSchema, UsersSchema } from "@/entities/users/users.dto";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { UsersController } from "@/entities/users/users.controller";
import { authMiddleware } from "@/middlewares";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { zodValidation } from "@/middlewares/zod-validation";
import { z } from "zod";
import { FindByQuerySchema } from "@/schemas/find-by-query";
import { Router } from "express";
import { RegisterSchema } from "@/entities/auth/auth.dto";
import { ImportFileSchema } from "@/schemas/import-file";
import { uploadImportMiddleware } from "@/common/multer/multer";

const usersRouter = Router();
usersRouter.use(authMiddleware);

const TAG = "Users";
const ROUTE = `/${TAG.toLowerCase()}`;

export const usersRegistry = new OpenAPIRegistry();
const usersController = new UsersController();

usersRegistry.register(TAG, UsersSchema);

usersRegistry.registerPath({
  method: "get",
  path: ROUTE,
  summary: `Get all ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.array(UsersSchema), "Success"),
});
usersRouter.get("/", usersController.getAll);

//====================================================================================================

usersRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/import`,
  tags: [TAG],
  summary: `Import ${TAG}`,
  request: {
    body: {
      content: { "multipart/form-data": { schema: ImportFileSchema } },
    },
  },
  responses: createApiResponse(z.null(), `${TAG}s Imported Successfully`),
});
usersRouter.post("/import", uploadImportMiddleware, usersController.import);

//====================================================================================================

usersRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/export`,
  summary: `Export ${TAG}`,
  tags: [TAG],
  responses: createApiResponse(z.null(), `${TAG}s Exported Successfully`),
});
usersRouter.get("/export", usersController.export);

//====================================================================================================

usersRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/{id}`,
  tags: [TAG],
  summary: `Get ${TAG} by id`,
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(UsersSchema, "Success"),
});
usersRouter.get("/:id", usersController.getById);

//====================================================================================================

usersRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/uuid/{uuid}`,
  tags: [TAG],
  summary: `Get ${TAG} by uuid`,
  request: {
    params: z.object({ uuid: z.string() }),
  },
  responses: createApiResponse(UsersSchema, "Success"),
});
usersRouter.get("/uuid/:uuid", usersController.getByUuid);

//====================================================================================================

usersRegistry.registerPath({
  method: "get",
  path: `${ROUTE}/email/{email}`,
  tags: [TAG],
  summary: `Get ${TAG} by email`,
  request: {
    params: z.object({ email: z.string() }),
  },
  responses: createApiResponse(UsersSchema, "Success"),
});
usersRouter.get("/email/:email", usersController.getByEmail);

//====================================================================================================

usersRegistry.registerPath({
  method: "post",
  path: `${ROUTE}/find`,
  tags: [TAG],
  summary: `Find ${TAG} by query`,
  request: {
    body: {
      content: { "application/json": { schema: FindByQuerySchema } },
    },
  },
  responses: createApiResponse(z.array(FindByQuerySchema), "Success"),
});
usersRouter.post("/find", zodValidation(FindByQuerySchema), usersController.findByQuery);

//====================================================================================================

usersRegistry.registerPath({
  method: "post",
  path: ROUTE,
  tags: [TAG],
  summary: `Create ${TAG}`,
  request: {
    body: {
      content: { "application/json": { schema: RegisterSchema } },
    },
  },
  responses: createApiResponse(RegisterSchema, `${TAG} Created Successfully`),
});
usersRouter.post("/", zodValidation(RegisterSchema), usersController.create);

//====================================================================================================

usersRegistry.registerPath({
  method: "put",
  path: `${ROUTE}/{uuid}`,
  tags: [TAG],
  summary: `Update ${TAG}`,
  request: {
    params: z.object({ uuid: z.string() }),
    body: {
      content: { "application/json": { schema: UpdateUsersSchema } },
    },
  },
  responses: createApiResponse(UpdateUsersSchema, `${TAG} Updated Successfully`),
});
usersRouter.put("/:uuid", zodValidation(UpdateUsersSchema), usersController.update);

//====================================================================================================

usersRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/bulk`,
  tags: [TAG],
  summary: `Delete ${TAG} in bulk`,
  request: {
    body: {
      content: { "application/json": { schema: z.object({ uuids: z.array(z.string()) }) } },
    },
  },
  responses: createApiResponse(z.null(), `${TAG}s Deleted Successfully`),
});
usersRouter.delete(
  "/bulk",
  zodValidation(z.object({ uuids: z.array(z.string()) })),
  usersController.deleteAll,
);

//====================================================================================================

usersRegistry.registerPath({
  method: "delete",
  path: `${ROUTE}/{uuid}`,
  tags: [TAG],
  summary: `Delete ${TAG}`,
  request: {
    params: z.object({ uuid: z.string() }),
  },
  responses: createApiResponse(z.null(), `${TAG} Deleted Successfully`),
});
usersRouter.delete("/:uuid", usersController.delete);

export default usersRouter;


File: src/entities/files/files.service.ts
--------------------------------------------------
Content of src/entities/files/files.service.ts:
import { FilesRepository } from "@/entities/files/files.repository";
import createHttpError from "http-errors";
import { StatusCodes } from "http-status-codes";
import { logger } from "@/common/winston/winston";
import { UpdateFilesDto, UploadFilesDto } from "@/entities/files/files.dto";
import { v4 as uuidv4 } from "uuid";
export class FilesService {
  private filesRepository = new FilesRepository();

  async uploadFiles(fileData: UploadFilesDto) {
    try {
      logger.info("Uploading file metadata to the database", { fileData });
      const fileUpload = {
        ...fileData,
        uuid: uuidv4(),
        createdAt: new Date(),
        updatedAt: new Date(),
        views: "0",
        userId: "talhaakhter01@gmail.com",
      };
      return await this.filesRepository.createFile(fileUpload);
    } catch (error) {
      logger.warn("Error uploading file metadata", { error });
      throw createHttpError(StatusCodes.INTERNAL_SERVER_ERROR, "Error uploading file metadata.");
    }
  }

  async getFileById(id: string) {
    const file = await this.filesRepository.getFilesById(id);

    if (!file) {
      throw createHttpError(StatusCodes.NOT_FOUND, "File not found.");
    }

    return file;
  }

  async getAllFiles() {
    // eslint-disable-next-line no-return-await
    return await this.filesRepository.getAllFiles();
  }

  async updateFile(id: string, updateData: UpdateFilesDto) {
    const updatedFile = await this.filesRepository.updateFile(id, updateData);

    if (!updatedFile) {
      throw createHttpError(StatusCodes.NOT_FOUND, "File not found.");
    }

    return updatedFile;
  }

  async deleteFile(id: string) {
    const deletedFile = await this.filesRepository.deleteFile(id);

    if (!deletedFile) {
      throw createHttpError(StatusCodes.NOT_FOUND, "File not found.");
    }

    return deletedFile;
  }
}


File: src/entities/files/files.controller.ts
--------------------------------------------------
Content of src/entities/files/files.controller.ts:
import { NextFunction, Response } from "express";
import { FilesService } from "@/entities/files/files.service";
import { UpdateFilesDto, UploadFilesDto } from "@/entities/files/files.dto";
import { logger } from "@/common/winston/winston";
import { CustomRequest } from "@/types/request";
import { saveFileToDisk } from "@/common/multer/save-file-to-disk";
import { updateImageToDisk } from "@/common/multer/update-file-to-disk";
import { deleteFileFromDisk } from "@/common/multer/delete-file-from-disk";

const filesService = new FilesService();
export class FilesController {
  async getAllFiles(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    const { loggedUser } = req;
    try {
      const files = await filesService.getAllFiles();
      res.json(files);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error getting files", { error: error.message, loggedUser });
      }
      next(error);
    }
  }

  async getFileById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    const { id } = req.params;
    const { loggedUser } = req;
    try {
      const file = await filesService.getFileById(id);
      res.json(file);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error getting file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  }

  async createFile(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    const { loggedUser } = req;
    const { buffer, mimetype } = req.file!;
    const { tags } = req.body;

    try {
      const { fileName, filePath } = await saveFileToDisk(req.file);
      const fileText = `data:${mimetype};base64,${buffer.toString("base64")}`;
      const fileData: UploadFilesDto = { fileName, filePath, fileText, userId: loggedUser!, tags };
      const newFile = await filesService.uploadFiles(fileData);
      res.status(201).json(newFile);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error uploading file", { error: error.message, loggedUser });
      }
      next(error);
    }
  }

  async updateFile(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    const { loggedUser } = req;
    const { id } = req.params;
    const { buffer, mimetype } = req.file!;
    const updateData = req.body;
    try {
      const existFile = await filesService.getFileById(id);
      if (!existFile) {
        throw new Error("File not found");
      }
      const { fileName, filePath } = await updateImageToDisk(existFile.fileName!, req.file);
      const fileText = `data:${mimetype};base64,${buffer.toString("base64")}`;
      const fileData: UpdateFilesDto = {
        fileName,
        filePath,
        fileText,
        userId: loggedUser!,
        ...updateData,
      };
      const updatedFile = await filesService.updateFile(id, fileData);
      res.json(updatedFile);
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error updating file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  }

  async deleteFile(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    const { loggedUser } = req;
    const { id } = req.params;
    try {
      const existFile = await filesService.getFileById(id);
      if (!existFile) {
        throw new Error("File not found");
      }
      await deleteFileFromDisk(existFile.fileName!);
      await filesService.deleteFile(id);
      res.status(204).send();
    } catch (error) {
      if (error instanceof Error) {
        logger.warn("Error deleting file", { error: error.message, loggedUser, id });
      }
      next(error);
    }
  }
}


File: src/entities/files/files.dto.ts
--------------------------------------------------
Content of src/entities/files/files.dto.ts:
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
import { model } from "mongoose";
import { z } from "zod";
import { zodSchema } from "@zodyac/zod-mongoose";

extendZodWithOpenApi(z);

export const FilesSchema = z.object({
  uuid: z.string(),
  filePath: z.string().optional(),
  tags: z.string(),
  fileName: z.string().optional(),
  fileText: z.string().optional(),
  views: z.string().optional(),
  userId: z.string().optional(),
  createdAt: z
    .date()
    .default(() => new Date())
    .optional(),
  updatedAt: z
    .date()
    .default(() => new Date())
    .optional(),
});

export const UploadFilesSchema = FilesSchema.omit({
  uuid: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload")
    .optional(),
});

export const UpdateFilesSchema = FilesSchema.omit({
  uuid: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  file: z
    .any()
    .openapi({
      type: "string",
      format: "binary",
    })
    .describe("The file to upload")
    .optional(),
});

export type FilesDto = z.infer<typeof FilesSchema>;
export type UploadFilesDto = z.infer<typeof UploadFilesSchema>;
export type UpdateFilesDto = z.infer<typeof UpdateFilesSchema>;

const schema = zodSchema(FilesSchema);
export const FilesModel = model("Files", schema);


File: src/entities/files/files.repository.ts
--------------------------------------------------
Content of src/entities/files/files.repository.ts:
import { FilesDto, FilesModel, UpdateFilesDto } from "@/entities/files/files.dto";
import { logger } from "@/common/winston/winston";

export class FilesRepository {
  async getAllFiles(): Promise<FilesDto[]> {
    logger.info("Fetching all files from repository");
    // eslint-disable-next-line no-return-await
    return await FilesModel.find();
  }

  async getFilesById(uuid: string): Promise<FilesDto | null> {
    logger.info(`Fetching file with ID: ${uuid}`);
    // eslint-disable-next-line no-return-await
    return await FilesModel.findOne({ uuid });
  }

  async createFile(file: FilesDto): Promise<FilesDto> {
    logger.info("Creating a new file in the repository");
    const newFile = new FilesModel(file);
    // eslint-disable-next-line no-return-await
    return await newFile.save();
  }

  async updateFile(uuid: string, updateData: UpdateFilesDto): Promise<FilesDto | null> {
    logger.info(`Updating file with ID: ${uuid}`);
    // eslint-disable-next-line no-return-await
    return await FilesModel.findOneAndUpdate({ uuid }, updateData, { new: true });
  }

  async deleteFile(uuid: string): Promise<boolean | null> {
    logger.info(`Deleting file with ID: ${uuid}`);
    // eslint-disable-next-line no-return-await
    return await FilesModel.findOneAndDelete({ uuid });
  }
}


File: src/entities/files/files.route.ts
--------------------------------------------------
Content of src/entities/files/files.route.ts:
import { Router } from "express";
import { uploadMiddleware } from "@/common/multer/multer";
import { FilesController } from "@/entities/files/files.controller";
import { OpenAPIRegistry } from "@asteasolutions/zod-to-openapi";
import { FilesSchema, UpdateFilesSchema, UploadFilesSchema } from "@/entities/files/files.dto";
import { createApiResponse } from "@/common/swagger/swagger-response-builder";
import { z } from "zod";
import { authMiddleware, zodValidation } from "@/middlewares";

const filesRouter = Router();
filesRouter.use(authMiddleware);

export const filesRegistry = new OpenAPIRegistry();
const filesController = new FilesController();

filesRegistry.register("Files", FilesSchema);

filesRegistry.registerPath({
  method: "get",
  path: "/files",
  summary: "Get all files",
  tags: ["File"],
  responses: createApiResponse(z.array(FilesSchema), "Success"),
});
filesRouter.get("/", filesController.getAllFiles);

filesRegistry.registerPath({
  method: "get",
  path: "/files/{id}",
  tags: ["File"],
  summary: "Get a single file",
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(FilesSchema, "Success"),
});
filesRouter.get("/:id", filesController.getFileById);

filesRegistry.registerPath({
  method: "post",
  path: "/files/upload",
  tags: ["File"],
  request: {
    body: {
      content: { "multipart/form-data": { schema: UploadFilesSchema } },
    },
  },
  responses: createApiResponse(UploadFilesSchema, "File uploaded Successfully"),
});
filesRouter.post(
  "/upload",
  uploadMiddleware,
  zodValidation(UploadFilesSchema),
  filesController.createFile,
);

filesRegistry.registerPath({
  method: "put",
  path: "/files/{id}",
  tags: ["File"],
  request: {
    params: z.object({ id: z.string() }),
    body: {
      content: { "multipart/form-data": { schema: UpdateFilesSchema } },
    },
  },
  responses: createApiResponse(UpdateFilesSchema, "File updated Successfully"),
});
filesRouter.put(
  "/:id",
  uploadMiddleware,
  zodValidation(UpdateFilesSchema),
  filesController.updateFile,
);

filesRegistry.registerPath({
  method: "delete",
  path: "/files/{id}",
  tags: ["File"],
  summary: "Delete file",
  request: {
    params: z.object({ id: z.string() }),
  },
  responses: createApiResponse(z.null(), "File deleted Successfully"),
});
filesRouter.delete("/:id", filesController.deleteFile);

export default filesRouter;


